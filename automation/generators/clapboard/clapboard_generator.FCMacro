"""
Parametric Clapboard Siding Generator for FreeCAD v5.1.0
Generates realistic clapboard siding from explicitly selected FACES

Author: Generated for model railroading (HO/O/N scale)
Usage: Click on specific faces in the 3D view, then run this macro

Version History:
- 5.1.0: REMOVE: Trim logic (defer to smart_trim generator)
         CHANGE: Fuse clapboards directly to source wall (boolean now, validate early)
         REMOVE: trim_width and trim_thickness parameters
- 5.0.1: ADD: Sketch geometry validation - detect degenerate and duplicate edges
- 5.0.0: REWRITE - Face-based selection (not sketches)
"""

import FreeCAD as App
import Part
from FreeCAD import Vector
import math

VERSION = "5.1.0"
GENERATOR_NAME = "clapboard_generator"
CLAPBOARD_TRIM_OFFSET = 0.05  # mm - Keep clapboard bottom slightly inboard of trim to avoid coplanar faces


def find_spreadsheet(doc, preferred_names):
    """Find spreadsheet by checking both object name and label."""
    for ss_name in preferred_names:
        obj = doc.getObject(ss_name)
        if obj and obj.TypeId == 'Spreadsheet::Sheet':
            print(f"Found spreadsheet by name: '{ss_name}'")
            return obj
        
        for obj in doc.Objects:
            if obj.TypeId == 'Spreadsheet::Sheet' and obj.Label == ss_name:
                print(f"Found spreadsheet by label: '{ss_name}' (object name: '{obj.Name}')")
                return obj
    
    return None


def get_params_from_spreadsheet(doc):
    """Try to read clapboard parameters from spreadsheet."""
    preferred_names = ["params", "ClapboardParameters", "BuildingParameters", "Spreadsheet"]
    
    ss = find_spreadsheet(doc, preferred_names)
    if ss is None:
        return None
    
    params = {}
    param_map = {
        'clapboard_height': ['clapboard_height', 'ClapboardHeight', 'clapboardHeight', 'reveal'],
        'clapboard_thickness': ['clapboard_thickness', 'ClapboardThickness', 'thickness', 'materialThickness'],
    }
    
    for param_key, possible_names in param_map.items():
        for name in possible_names:
            try:
                val = ss.get(name)
                if val is not None:
                    params[param_key] = float(val)
                    break
            except:
                continue
    
    return params if params else None


def check_for_degenerate_edges(wire):
    """Detect edges with zero or near-zero length."""
    degenerate = []
    tolerance = 0.001  # mm
    
    for i, edge in enumerate(wire.Edges):
        if edge.Length < tolerance:
            degenerate.append((i, edge.Length))
    
    return degenerate


def check_for_duplicate_edges(wire):
    """Detect duplicate or overlapping edges in a wire."""
    edges = wire.Edges
    duplicates = []
    tolerance = 0.001  # mm
    
    for i in range(len(edges)):
        for j in range(i + 1, len(edges)):
            edge1 = edges[i]
            edge2 = edges[j]
            
            e1_start = edge1.valueAt(edge1.FirstParameter)
            e1_end = edge1.valueAt(edge1.LastParameter)
            e2_start = edge2.valueAt(edge2.FirstParameter)
            e2_end = edge2.valueAt(edge2.LastParameter)
            
            if (e1_start.distanceToPoint(e2_start) < tolerance and
                e1_end.distanceToPoint(e2_end) < tolerance):
                duplicates.append((i, j))
            elif (e1_start.distanceToPoint(e2_end) < tolerance and
                  e1_end.distanceToPoint(e2_start) < tolerance):
                duplicates.append((i, j))
    
    return duplicates


def validate_wire_geometry(wire, wire_name="Wire"):
    """Validate wire for common geometry errors."""
    degenerate = check_for_degenerate_edges(wire)
    if degenerate:
        errors = [f"  Edge {i}: length={length:.6f}mm" for i, length in degenerate]
        raise ValueError(
            f"{wire_name} has {len(degenerate)} degenerate edge(s):\n" +
            "\n".join(errors) +
            "\nThese are likely duplicate/overlapping lines in your sketch.\n" +
            "Check for stray geometry in the Sketcher!"
        )
    
    duplicates = check_for_duplicate_edges(wire)
    if duplicates:
        errors = [f"  Edges {i} and {j}" for i, j in duplicates]
        raise ValueError(
            f"{wire_name} has {len(duplicates)} duplicate edge(s):\n" +
            "\n".join(errors) +
            "\nThese are overlapping lines in your sketch.\n" +
            "Check for stray geometry in the Sketcher!"
        )


def get_selected_faces():
    """Get explicitly selected faces from FreeCAD selection."""
    import FreeCADGui
    
    faces_list = []
    selection_ex = FreeCADGui.Selection.getSelectionEx()
    
    if len(selection_ex) == 0:
        raise ValueError("No objects selected!")
    
    for sel_obj in selection_ex:
        obj = sel_obj.Object
        
        if not hasattr(obj, 'Shape'):
            print(f"Warning: '{obj.Label}' has no Shape property")
            continue
        
        if len(sel_obj.SubElementNames) > 0:
            for sub_name in sel_obj.SubElementNames:
                if sub_name.startswith('Face'):
                    try:
                        face_num = int(sub_name[4:]) - 1
                        
                        if face_num < len(obj.Shape.Faces):
                            face = obj.Shape.Faces[face_num]
                            faces_list.append((obj, face, face_num))
                            print(f"  Selected: {sub_name} from '{obj.Label}'")
                        else:
                            print(f"Warning: Face index {face_num} out of range for '{obj.Label}'")
                    except ValueError:
                        print(f"Warning: Could not parse face number from '{sub_name}'")
        else:
            raise ValueError(
                f"Please select specific FACES, not the whole object!\n"
                f"Click in the 3D view to select '{obj.Label}',\n"
                f"then Ctrl+click on the specific faces you want clapboards on."
            )
    
    if len(faces_list) == 0:
        raise ValueError("No faces explicitly selected! Please Ctrl+click on the faces you want.")
    
    return faces_list


def get_face_wires(face):
    """Get wires from a face (outer boundary and holes)."""
    wires = face.Wires
    
    if len(wires) == 0:
        raise ValueError("Face has no wires!")
    
    outer_wire = max(wires, key=lambda w: abs(Part.Face(w).Area))
    hole_wires = [w for w in wires if w != outer_wire]
    
    if not outer_wire.isClosed():
        raise ValueError("Outer wire is not closed! Cannot generate clapboards.")
    
    for i, hw in enumerate(hole_wires):
        if not hw.isClosed():
            raise ValueError(f"Hole wire {i} is not closed!")
    
    validate_wire_geometry(outer_wire, "Outer wire")
    
    for i, hw in enumerate(hole_wires):
        validate_wire_geometry(hw, f"Hole wire {i}")
    
    return outer_wire, hole_wires


def get_face_bounding_box_local(face):
    """Get bounding box of a face in its local coordinates."""
    return face.BoundBox


def get_face_normal(face):
    """Get the normal vector of a face at its center."""
    u_range = face.ParameterRange[:2]
    v_range = face.ParameterRange[2:]
    u_mid = (u_range[0] + u_range[1]) / 2
    v_mid = (v_range[0] + v_range[1]) / 2
    normal = face.normalAt(u_mid, v_mid)
    return normal


def detect_face_orientation(bbox):
    """Detect which plane a face lies in based on bounding box extents."""
    x_extent = bbox.XMax - bbox.XMin
    y_extent = bbox.YMax - bbox.YMin
    z_extent = bbox.ZMax - bbox.ZMin
    
    tolerance = 0.1
    
    if x_extent < tolerance:
        return 'z', 'y', 'x'
    elif y_extent < tolerance:
        return 'z', 'x', 'y'
    elif z_extent < tolerance:
        return 'y', 'x', 'z'
    else:
        if z_extent >= y_extent and z_extent >= x_extent:
            if x_extent > y_extent:
                return 'z', 'x', 'y'
            else:
                return 'z', 'y', 'x'
        else:
            return 'y', 'x', 'z'


def find_gable_edges(wire, vertical_axis='y', angle_tolerance=5.0):
    """Find non-vertical edges in the wire that define gable profiles."""
    gable_edges = []
    
    if vertical_axis == 'z':
        vert_dir = Vector(0, 0, 1)
    else:
        vert_dir = Vector(0, 1, 0)
    
    for edge in wire.Edges:
        if edge.Length < 0.01:
            continue
        
        try:
            direction = edge.tangentAt(edge.FirstParameter)
            direction.normalize()
            
            dot_product = abs(direction.dot(vert_dir))
            angle = math.degrees(math.acos(min(1.0, dot_product)))
            
            if angle > angle_tolerance:
                gable_edges.append(edge)
                print(f"  Found gable edge: angle={angle:.1f}° from vertical")
        
        except Exception as e:
            print(f"Warning: Could not analyze edge: {e}")
    
    return gable_edges


def create_clapboard_course_local(vert_position, bbox, clapboard_height, clapboard_thickness,
                                  vertical_axis, horizontal_axis, normal):
    """Create one horizontal clapboard course."""
    actual_thick = clapboard_thickness - CLAPBOARD_TRIM_OFFSET
    thin_thickness = 0.01
    
    if vertical_axis == 'z':
        if horizontal_axis == 'x':
            h_min, h_max = bbox.XMin - 0.1, bbox.XMax + 0.1
            v_bottom, v_top = vert_position, vert_position + clapboard_height
            v_max = bbox.ZMax + 0.1
            
            if v_top > v_max:
                v_top = v_max
            if v_bottom >= bbox.ZMax:
                return None
            
            base_y = bbox.YMin
            thick_offset = actual_thick if normal.y > 0 else -actual_thick
            thin_offset = thin_thickness if normal.y > 0 else -thin_thickness
            
            outside_wire = Part.makePolygon([
                Vector(h_min, base_y + thick_offset, v_bottom),
                Vector(h_max, base_y + thick_offset, v_bottom),
                Vector(h_max, base_y + thin_offset, v_top),
                Vector(h_min, base_y + thin_offset, v_top),
                Vector(h_min, base_y + thick_offset, v_bottom)
            ])
            inside_wire = Part.makePolygon([
                Vector(h_min, base_y, v_bottom),
                Vector(h_max, base_y, v_bottom),
                Vector(h_max, base_y, v_top),
                Vector(h_min, base_y, v_top),
                Vector(h_min, base_y, v_bottom)
            ])
            clapboard_shape = Part.makeLoft([inside_wire, outside_wire], True)
            
        else:
            h_min, h_max = bbox.YMin - 0.1, bbox.YMax + 0.1
            v_bottom, v_top = vert_position, vert_position + clapboard_height
            v_max = bbox.ZMax + 0.1
            
            if v_top > v_max:
                v_top = v_max
            if v_bottom >= bbox.ZMax:
                return None
            
            base_x = bbox.XMin
            thick_offset = actual_thick if normal.x > 0 else -actual_thick
            thin_offset = thin_thickness if normal.x > 0 else -thin_thickness
            
            outside_wire = Part.makePolygon([
                Vector(base_x + thick_offset, h_min, v_bottom),
                Vector(base_x + thick_offset, h_max, v_bottom),
                Vector(base_x + thin_offset, h_max, v_top),
                Vector(base_x + thin_offset, h_min, v_top),
                Vector(base_x + thick_offset, h_min, v_bottom)
            ])
            inside_wire = Part.makePolygon([
                Vector(base_x, h_min, v_bottom),
                Vector(base_x, h_max, v_bottom),
                Vector(base_x, h_max, v_top),
                Vector(base_x, h_min, v_top),
                Vector(base_x, h_min, v_bottom)
            ])
            clapboard_shape = Part.makeLoft([inside_wire, outside_wire], True)
    else:
        h_min, h_max = bbox.XMin - 0.1, bbox.XMax + 0.1
        v_bottom, v_top = vert_position, vert_position + clapboard_height
        v_max = bbox.YMax + 0.1
        
        if v_top > v_max:
            v_top = v_max
        if v_bottom >= bbox.YMax:
            return None
        
        base_z = 0
        thick_offset = actual_thick if normal.z > 0 else -actual_thick
        thin_offset = thin_thickness if normal.z > 0 else -thin_thickness
        
        outside_wire = Part.makePolygon([
            Vector(h_min, v_bottom, base_z + thick_offset),
            Vector(h_max, v_bottom, base_z + thick_offset),
            Vector(h_max, v_top, base_z + thin_offset),
            Vector(h_min, v_top, base_z + thin_offset),
            Vector(h_min, v_bottom, base_z + thick_offset)
        ])
        inside_wire = Part.makePolygon([
            Vector(h_min, v_bottom, base_z),
            Vector(h_max, v_bottom, base_z),
            Vector(h_max, v_top, base_z),
            Vector(h_min, v_top, base_z),
            Vector(h_min, v_bottom, base_z)
        ])
        clapboard_shape = Part.makeLoft([inside_wire, outside_wire], True)
    
    return clapboard_shape


def create_clapboard_wall(face, source_object, clapboard_height=0.8, clapboard_thickness=0.2):
    """Generate clapboard siding from a face and fuse to source wall."""
    print(f"\nGenerating clapboards for face from '{source_object.Label}' (v{VERSION})...")
    
    outer_wire, hole_wires = get_face_wires(face)
    
    bbox = get_face_bounding_box_local(face)
    print(f"Face bounds: X=[{bbox.XMin:.1f}, {bbox.XMax:.1f}], "
          f"Y=[{bbox.YMin:.1f}, {bbox.YMax:.1f}], Z=[{bbox.ZMin:.1f}, {bbox.ZMax:.1f}]")
    
    vertical_axis, horizontal_axis, plane_normal = detect_face_orientation(bbox)
    print(f"Orientation: vertical={vertical_axis}, horizontal={horizontal_axis}")
    
    normal = get_face_normal(face)
    print(f"Face normal (local): ({normal.x:.3f}, {normal.y:.3f}, {normal.z:.3f})")
    
    parts = []
    
    # Create clapboard courses
    print("Creating clapboard courses...")
    if vertical_axis == 'z':
        wall_height = bbox.ZMax - bbox.ZMin
        vert_min = bbox.ZMin
    else:
        wall_height = bbox.YMax - bbox.YMin
        vert_min = bbox.YMin
    
    num_courses = int(math.ceil(wall_height / clapboard_height))
    print(f"Height: {wall_height:.2f}mm = {num_courses} courses")
    
    successful = 0
    for i in range(num_courses):
        overlap = 0.01 if i > 0 else 0
        vert_pos = vert_min + i * clapboard_height - overlap
        
        try:
            clapboard = create_clapboard_course_local(
                vert_pos, bbox, clapboard_height, clapboard_thickness,
                vertical_axis, horizontal_axis, normal
            )
            if clapboard:
                parts.append(clapboard)
                successful += 1
        except Exception as e:
            print(f"Warning: Course {i} failed: {e}")
    
    print(f"Created {successful}/{num_courses} courses")
    
    if len(parts) == 0:
        raise RuntimeError("No clapboard courses created!")
    
    # Fuse all clapboard courses
    print("Fusing clapboard courses...")
    if len(parts) == 1:
        fused_clapboards = parts[0]
    else:
        fused_clapboards = parts[0].fuse(parts[1:])
    
    print(f"Fused clapboards volume: {fused_clapboards.Volume:.2f} mm³")
    
    # Check for gable edges
    print("Checking for gable edges...")
    gable_edges = find_gable_edges(outer_wire, vertical_axis)
    
    if len(gable_edges) > 0:
        print(f"Found {len(gable_edges)} gable edges - cutting profile...")
        try:
            gable_solid_out = face.extrude(normal * clapboard_thickness * 3)
            gable_solid_in = face.extrude(normal * -(clapboard_thickness * 2))
            gable_solid = gable_solid_out.fuse(gable_solid_in)
            fused_clapboards = fused_clapboards.common(gable_solid)
        except Exception as e:
            print(f"Warning: Gable cutting failed: {e}")
    
    # Cut holes
    print(f"Cutting {len(hole_wires)} holes...")
    final_clapboards = fused_clapboards
    
    holes_cut = 0
    for i, hole_wire in enumerate(hole_wires):
        try:
            hole_face = Part.Face(hole_wire)
            hole_volume_fwd = hole_face.extrude(normal * clapboard_thickness * 2)
            hole_volume_back = hole_face.extrude(normal * -(clapboard_thickness * 3))
            hole_volume = hole_volume_fwd.fuse(hole_volume_back)
            
            volume_before = final_clapboards.Volume
            final_clapboards = final_clapboards.cut(hole_volume)
            volume_after = final_clapboards.Volume
            
            if volume_before - volume_after > 0.001:
                holes_cut += 1
                print(f"  Hole {i}: OK")
        except Exception as e:
            print(f"  Warning: Hole {i} failed: {e}")
    
    print(f"Cut {holes_cut}/{len(hole_wires)} holes")
    
    # Return only the clapboard skin geometry (don't fuse with source wall)
    print(f"\nClapboard siding complete (compounding with source wall in document)")
    print(f"Clapboard volume: {final_clapboards.Volume:.2f} mm³")
    return final_clapboards


# Main execution
if __name__ == '__main__' or __name__ == '__console__' or __name__ == '__plugins__':
    doc = App.activeDocument()
    if doc is None:
        App.Console.PrintError("No active document!\n")
    else:
        try:
            faces_list = get_selected_faces()
        except ValueError as e:
            App.Console.PrintError(f"Error: {e}\n")
            faces_list = []
        
        if len(faces_list) == 0:
            App.Console.PrintError("No faces selected!\n")
        else:
            params = get_params_from_spreadsheet(doc)
            
            if params:
                App.Console.PrintMessage("Using parameters from spreadsheet\n")
                clapboard_height = params.get('clapboard_height', 0.8)
                clapboard_thickness = params.get('clapboard_thickness', 0.2)
            else:
                App.Console.PrintMessage("Using HO scale defaults\n")
                clapboard_height = 0.8
                clapboard_thickness = 0.2
            
            if len(faces_list) > 1:
                App.Console.PrintMessage(f"\n=== Processing {len(faces_list)} faces ===\n")
            
            success_count = 0
            fail_count = 0
            
            for source_obj, face, face_idx in faces_list:
                try:
                    clapboard_skin = create_clapboard_wall(
                        face, source_obj, clapboard_height, clapboard_thickness
                    )
                    
                    # Create a compound containing the source wall and the clapboard skin
                    compound_obj = doc.addObject("Part::Compound", 
                                                f"ClapboardWall_{source_obj.Label}_F{face_idx}")
                    
                    # Add source wall reference and clapboard skin to compound
                    compound_obj.Links = [source_obj]
                    
                    # Create a separate feature object for the clapboard skin geometry
                    skin_obj = doc.addObject("Part::Feature", 
                                            f"ClapboardWall_{source_obj.Label}_F{face_idx}_skin")
                    skin_obj.Shape = clapboard_skin
                    skin_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata")
                    skin_obj.GeneratorName = GENERATOR_NAME
                    skin_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata")
                    skin_obj.GeneratorVersion = VERSION
                    skin_obj.addProperty("App::PropertyString", "SourceObject", "Metadata")
                    skin_obj.SourceObject = source_obj.Label
                    skin_obj.addProperty("App::PropertyInteger", "FaceIndex", "Metadata")
                    skin_obj.FaceIndex = face_idx
                    
                    # Update compound to reference both
                    compound_obj.Links = [source_obj, skin_obj]
                    
                    App.Console.PrintMessage(f"✓ '{compound_obj.Label}' created with skin geometry\n")
                    success_count += 1
                    
                except Exception as e:
                    App.Console.PrintError(f"✗ Face {face_idx} from '{source_obj.Label}': {e}\n")
                    fail_count += 1
            
            doc.recompute()
            
            App.Console.PrintMessage(f"\n=== SUMMARY: {success_count} succeeded, {fail_count} failed ===\n")
            
            try:
                import FreeCADGui
                FreeCADGui.activeDocument().activeView().viewAxonometric()
                FreeCADGui.SendMsgToActiveView("ViewFit")
            except:
                pass
