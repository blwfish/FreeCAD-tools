"""
Parametric Brick Generator Macro v3.0.0

Simplified UI layer that orchestrates brick generation using brick_geometry library.
Handles FreeCAD coordinate systems, object creation, and punchout preparation.

Openings (windows, doors): Use the "punchout" method - create the geometry separately
and cut from the wall. See README for details.

Version: 3.0.0
Date: 2025-11-26
"""

import FreeCAD as App
import Part
import math
import sys
import os

# Try to import the geometry library
try:
    from brick_geometry import BrickGeometry
except ImportError:
    print("ERROR: Could not import brick_geometry module")
    print("Make sure brick_geometry.py is in the same directory as this macro")
    sys.exit(1)


def get_face_coordinate_system(face):
    """
    Establish a coordinate system for the face.
    
    Returns:
        tuple: (origin, u_vec, v_vec, normal, u_length, v_length)
    
    Coordinate system:
    - origin: lowest Z point on the outer wire
    - u_vec: horizontal direction (left to right)
    - v_vec: vertical direction (bottom to top)
    - normal: perpendicular to wall (outward)
    """
    
    # Get the outer boundary wire (ignores holes)
    outer_wire = face.OuterWire
    
    # Find the lowest Z point as origin
    vertices = outer_wire.Vertexes
    sorted_by_z = sorted(vertices, key=lambda v: v.Point.z)
    origin = sorted_by_z[0].Point
    
    # Get edges from outer wire only
    outer_edges = outer_wire.Edges
    
    # Find edges that share the origin vertex
    origin_edges = []
    for edge in outer_edges:
        v1 = edge.Vertexes[0].Point
        v2 = edge.Vertexes[1].Point
        if v1.distanceToPoint(origin) < 0.001 or v2.distanceToPoint(origin) < 0.001:
            origin_edges.append(edge)
    
    if len(origin_edges) < 2:
        raise ValueError(f"Need at least 2 edges from origin, found {len(origin_edges)}")
    
    # Sort by length - U (width) is longer, V (height) is shorter
    sorted_edges = sorted(origin_edges, key=lambda e: e.Length)
    v_edge = sorted_edges[0]  # Shorter edge = height
    u_edge = sorted_edges[1]  # Longer edge = width
    
    # Get direction vectors
    if u_edge.Vertexes[0].Point.distanceToPoint(origin) < 0.001:
        u_vec = u_edge.Vertexes[1].Point.sub(u_edge.Vertexes[0].Point).normalize()
    else:
        u_vec = u_edge.Vertexes[0].Point.sub(u_edge.Vertexes[1].Point).normalize()
    
    if v_edge.Vertexes[0].Point.distanceToPoint(origin) < 0.001:
        v_vec = v_edge.Vertexes[1].Point.sub(v_edge.Vertexes[0].Point).normalize()
    else:
        v_vec = v_edge.Vertexes[0].Point.sub(v_edge.Vertexes[1].Point).normalize()
    
    # Ensure V vector points UP (positive Z)
    if v_vec.z < 0:
        v_vec = App.Vector(-v_vec.x, -v_vec.y, -v_vec.z)
    
    # Get face normal
    u_range = face.ParameterRange[:2]
    v_range = face.ParameterRange[2:]
    u_mid = (u_range[0] + u_range[1]) / 2
    v_mid = (v_range[0] + v_range[1]) / 2
    normal = face.normalAt(u_mid, v_mid)
    
    # Get lengths from outer wire edges
    u_length = u_edge.Length
    v_length = v_edge.Length
    
    return origin, u_vec, v_vec, normal, u_length, v_length


def scale_vector(vec, scale):
    """Helper to scale a vector."""
    return App.Vector(vec.x * scale, vec.y * scale, vec.z * scale)


def create_brick_from_def(brick_def, origin, u_vec, v_vec, normal):
    """
    Create a FreeCAD brick solid from a brick definition.
    
    Args:
        brick_def: BrickDef namedtuple with position, dimensions, and type
        origin: Wall origin point
        u_vec: Horizontal direction vector
        v_vec: Vertical direction vector
        normal: Wall normal vector
        
    Returns:
        Part.Shape: Positioned and rotated brick solid
    """
    
    # Create the brick box
    brick = Part.makeBox(brick_def.width, brick_def.height, brick_def.depth)
    
    # Position in local 2D coordinates
    position = origin + scale_vector(u_vec, brick_def.u) + scale_vector(v_vec, brick_def.v)
    brick.translate(position)
    
    # Rotate to align with face
    # This is the tricky part: align the brick's local coordinate system to the wall's
    z_axis = App.Vector(0, 0, 1)
    rot1 = App.Rotation(z_axis, normal)
    x_after_rot1 = rot1.multVec(App.Vector(1, 0, 0))
    rot2 = App.Rotation(x_after_rot1, u_vec)
    combined_rotation = rot2.multiply(rot1)
    brick.rotate(position, combined_rotation.Axis, math.degrees(combined_rotation.Angle))
    
    return brick


def get_params_from_spreadsheet(doc):
    """Try to read parameters from spreadsheet."""
    params = {}
    
    try:
        ss = doc.getObject("Spreadsheet")
        if ss is None:
            return None
        
        param_map = {
            'brick_width': 'brickWidth',
            'brick_height': 'brickHeight',
            'brick_depth': 'brickDepth',
            'mortar': 'mortar',
            'bond_type': 'bondType',
            'common_bond_count': 'commonBondCount'
        }
        
        for param_key, cell_name in param_map.items():
            try:
                val = ss.get(cell_name)
                if val is not None:
                    if param_key in ['bond_type']:
                        params[param_key] = str(val)
                    else:
                        params[param_key] = float(val)
            except:
                continue
        
        return params if params else None
    except:
        return None


# ============================================================================
# MACRO EXECUTION
# ============================================================================

if __name__ == '__main__' or __name__ == '__console__' or __name__ == '__plugins__':
    doc = App.ActiveDocument
    
    if doc is None:
        print("ERROR: No active document. Please create or open a document first.")
    else:
        # Get selection
        selection = App.Gui.Selection.getSelectionEx()
        
        if not selection:
            print("ERROR: Please select a sketch or face to apply bricks to.")
        else:
            sel_obj = selection[0].Object
            obj_name = sel_obj.Label
            
            # Determine if this is a sketch or a face selection
            is_sketch = (sel_obj.TypeId == 'Sketcher::SketchObject')
            
            if is_sketch:
                # Sketch-based workflow
                sketch = sel_obj
                
                print(f"\n{'='*60}")
                print(f"Generating bricks for sketch: {obj_name}")
                print(f"{'='*60}")
                
                try:
                    # Get sketch outer wire (assumes sketch is closed)
                    if not hasattr(sketch, 'Shape') or len(sketch.Shape.Wires) == 0:
                        raise ValueError("Sketch has no valid wires")
                    
                    outer_wire = max(sketch.Shape.Wires, key=lambda w: abs(Part.Face(w).Area))
                    face = Part.Face(outer_wire)
                    
                    # Get face coordinate system
                    origin, u_vec, v_vec, normal, u_length, v_length = get_face_coordinate_system(face)
                    
                    # Get parameters
                    params = get_params_from_spreadsheet(doc)
                    if params is None:
                        params = {}
                    
                    # Fill in defaults
                    brick_width = params.get('brick_width', 2.32)
                    brick_height = params.get('brick_height', 0.65)
                    brick_depth = params.get('brick_depth', 1.09)
                    mortar = params.get('mortar', 0.11)
                    bond_type = params.get('bond_type', 'stretcher')
                    common_bond_count = int(params.get('common_bond_count', 5))
                    
                    print(f"Wall dimensions: {u_length:.1f} x {v_length:.1f} mm")
                    print(f"Brick: {brick_width} x {brick_height} x {brick_depth} mm")
                    print(f"Mortar: {mortar} mm")
                    print(f"Bond: {bond_type}")
                    if bond_type.lower() == 'common':
                        print(f"Common bond count: {common_bond_count}")
                    print()
                    
                    # Generate geometry
                    print("Generating geometry...")
                    bg = BrickGeometry(
                        u_length=u_length,
                        v_length=v_length,
                        brick_width=brick_width,
                        brick_height=brick_height,
                        brick_depth=brick_depth,
                        mortar=mortar,
                        bond_type=bond_type,
                        common_bond_count=common_bond_count
                    )
                    
                    result = bg.generate()
                    brick_defs = result['bricks']
                    metadata = result['metadata']
                    
                    print(f"Generated {len(brick_defs)} brick definitions")
                    print(f"Bond pattern: {metadata['bond_type']}")
                    print(f"Number of courses: {metadata['num_courses']}")
                    print()
                    
                    # Create FreeCAD objects
                    print("Creating FreeCAD geometry...")
                    brick_shapes = []
                    for i, brick_def in enumerate(brick_defs):
                        brick = create_brick_from_def(brick_def, origin, u_vec, v_vec, normal)
                        brick_shapes.append(brick)
                        
                        if (i + 1) % 100 == 0:
                            print(f"  Created {i+1}/{len(brick_defs)} bricks...")
                    
                    print(f"Fusing {len(brick_shapes)} bricks...")
                    result_shape = brick_shapes[0]
                    for i, brick in enumerate(brick_shapes[1:], 1):
                        result_shape = result_shape.fuse(brick)
                        if (i + 1) % 100 == 0:
                            print(f"  Fused to {i+1} bricks...")
                    
                    # Create result object
                    result_obj = doc.addObject("Part::Feature", f"BrickedWall_{obj_name}")
                    result_obj.Shape = result_shape
                    
                    # Add metadata
                    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator that created this")
                    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
                    result_obj.addProperty("App::PropertyString", "SourceObject", "Metadata", "Source object name")
                    result_obj.addProperty("App::PropertyString", "BondType", "Metadata", "Bond pattern used")
                    result_obj.addProperty("App::PropertyInteger", "BrickCount", "Metadata", "Number of bricks generated")
                    
                    result_obj.GeneratorName = "brick_generator"
                    result_obj.GeneratorVersion = "3.0.0"
                    result_obj.SourceObject = obj_name
                    result_obj.BondType = bond_type
                    result_obj.BrickCount = len(brick_defs)
                    
                    doc.recompute()
                    
                    print(f"\n✓ Created: {result_obj.Label}")
                    print(f"  Brick count: {len(brick_defs)}")
                    print(f"  Bond type: {bond_type}\n")
                    print(f"{'='*60}")
                    print("SUCCESS!")
                    print(f"{'='*60}")
                    
                except Exception as e:
                    print(f"\n{'='*60}")
                    print(f"ERROR: {e}")
                    print(f"{'='*60}")
                    import traceback
                    traceback.print_exc()
            
            elif selection[0].SubObjects:
                # Face-based workflow
                sub_element = selection[0].SubElementNames[0]
                face_index = int(sub_element.replace('Face', '')) - 1
                face = sel_obj.Shape.Faces[face_index]
                
                print(f"\n{'='*60}")
                print(f"Generating bricks for: {obj_name}")
                print(f"Selected: {sub_element}")
                print(f"{'='*60}\n")
                
                try:
                    # Get face coordinate system
                    origin, u_vec, v_vec, normal, u_length, v_length = get_face_coordinate_system(face)
                    
                    # Get parameters
                    params = get_params_from_spreadsheet(doc)
                    if params is None:
                        params = {}
                    
                    # Fill in defaults
                    brick_width = params.get('brick_width', 2.32)
                    brick_height = params.get('brick_height', 0.65)
                    brick_depth = params.get('brick_depth', 1.09)
                    mortar = params.get('mortar', 0.11)
                    bond_type = params.get('bond_type', 'stretcher')
                    common_bond_count = int(params.get('common_bond_count', 5))
                    
                    print(f"Wall dimensions: {u_length:.1f} x {v_length:.1f} mm")
                    print(f"Brick: {brick_width} x {brick_height} x {brick_depth} mm")
                    print(f"Mortar: {mortar} mm")
                    print(f"Bond: {bond_type}")
                    if bond_type.lower() == 'common':
                        print(f"Common bond count: {common_bond_count}")
                    print()
                    
                    # Generate geometry
                    print("Generating geometry...")
                    bg = BrickGeometry(
                        u_length=u_length,
                        v_length=v_length,
                        brick_width=brick_width,
                        brick_height=brick_height,
                        brick_depth=brick_depth,
                        mortar=mortar,
                        bond_type=bond_type,
                        common_bond_count=common_bond_count
                    )
                    
                    result = bg.generate()
                    brick_defs = result['bricks']
                    metadata = result['metadata']
                    
                    print(f"Generated {len(brick_defs)} brick definitions")
                    print(f"Bond pattern: {metadata['bond_type']}")
                    print(f"Number of courses: {metadata['num_courses']}")
                    print()
                    
                    # Create FreeCAD objects
                    print("Creating FreeCAD geometry...")
                    brick_shapes = []
                    for i, brick_def in enumerate(brick_defs):
                        brick = create_brick_from_def(brick_def, origin, u_vec, v_vec, normal)
                        brick_shapes.append(brick)
                        
                        if (i + 1) % 100 == 0:
                            print(f"  Created {i+1}/{len(brick_defs)} bricks...")
                    
                    print(f"Fusing {len(brick_shapes)} bricks...")
                    result_shape = brick_shapes[0]
                    for i, brick in enumerate(brick_shapes[1:], 1):
                        result_shape = result_shape.fuse(brick)
                        if (i + 1) % 100 == 0:
                            print(f"  Fused to {i+1} bricks...")
                    
                    # Create result object
                    result_obj = doc.addObject("Part::Feature", f"BrickedWall_{obj_name}")
                    result_obj.Shape = result_shape
                    
                    # Add metadata
                    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator that created this")
                    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
                    result_obj.addProperty("App::PropertyString", "SourceObject", "Metadata", "Source object name")
                    result_obj.addProperty("App::PropertyString", "SourceFace", "Metadata", "Source face")
                    result_obj.addProperty("App::PropertyString", "BondType", "Metadata", "Bond pattern used")
                    result_obj.addProperty("App::PropertyInteger", "BrickCount", "Metadata", "Number of bricks generated")
                    
                    result_obj.GeneratorName = "brick_generator"
                    result_obj.GeneratorVersion = "3.0.0"
                    result_obj.SourceObject = obj_name
                    result_obj.SourceFace = sub_element
                    result_obj.BondType = bond_type
                    result_obj.BrickCount = len(brick_defs)
                    
                    doc.recompute()
                    
                    print(f"\n✓ Created: {result_obj.Label}")
                    print(f"  Brick count: {len(brick_defs)}")
                    print(f"  Bond type: {bond_type}\n")
                    print(f"{'='*60}")
                    print("SUCCESS!")
                    print(f"{'='*60}")
                    
                except Exception as e:
                    print(f"\n{'='*60}")
                    print(f"ERROR: {e}")
                    print(f"{'='*60}")
                    import traceback
                    traceback.print_exc()
            else:
                print("ERROR: Please select a sketch or face to apply bricks to.")
