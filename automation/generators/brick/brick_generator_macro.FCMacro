"""
Parametric Brick Generator Macro v3.0.0

Simplified UI layer that orchestrates brick generation using brick_geometry library.
Handles FreeCAD coordinate systems, object creation, and punchout preparation.

Openings (windows, doors): Use the "punchout" method - create the geometry separately
and cut from the wall. See README for details.

Version: 3.0.0
Date: 2025-11-26
"""

import FreeCAD as App
import Part
import math
import sys
import os

# Try to import the geometry library
# First try _lib/ subdirectory (standard installation location)
# Then try same directory (fallback for manual installation)
try:
    from brick_geometry import BrickGeometry
except ImportError:
    # Try adding _lib to path
    import sys
    macro_dir = os.path.dirname(__file__)
    lib_dir = os.path.join(macro_dir, '_lib')
    if lib_dir not in sys.path:
        sys.path.insert(0, lib_dir)
    
    try:
        from brick_geometry import BrickGeometry
    except ImportError:
        print("ERROR: Could not import brick_geometry module")
        print(f"Looked in: {macro_dir}")
        print(f"Looked in: {lib_dir}")
        print("Make sure brick_geometry.py is in _lib/ subdirectory or same directory as macro")
        sys.exit(1)


def get_face_coordinate_system(face):
    """
    Establish a coordinate system for the face using bounding box analysis.
    
    Returns:
        tuple: (origin, u_vec, v_vec, normal, u_length, v_length)
    
    Coordinate system:
    - origin: lowest corner of bounding box
    - u_vec: direction of largest extent (typically horizontal)
    - v_vec: direction of vertical extent (must include Z component)
    - normal: perpendicular to wall (from face)
    """
    
    outer_wire = face.OuterWire
    bbox = outer_wire.BoundBox
    
    # Origin at lowest corner
    origin = App.Vector(bbox.XMin, bbox.YMin, bbox.ZMin)
    
    # Get all vertices to analyze axis ranges
    vertices = outer_wire.Vertexes
    points = [v.Point for v in vertices]
    
    x_vals = [p.x for p in points]
    y_vals = [p.y for p in points]
    z_vals = [p.z for p in points]
    
    x_min, x_max = min(x_vals), max(x_vals)
    y_min, y_max = min(y_vals), max(y_vals)
    z_min, z_max = min(z_vals), max(z_vals)
    
    x_range = x_max - x_min
    y_range = y_max - y_min
    z_range = z_max - z_min
    
    # Identify the three axes by their ranges
    axes = [
        (x_range, 'x', App.Vector(1, 0, 0)),
        (y_range, 'y', App.Vector(0, 1, 0)),
        (z_range, 'z', App.Vector(0, 0, 1))
    ]
    axes.sort(reverse=True)  # Sort by range, largest first
    
    # The vertical axis should have Z component (be the Z-axis or one of the others)
    # Strategy: one of u/v should be Z, the other should be X or Y
    
    # Find which is the Z axis
    z_axis = None
    other_axes = []
    for rng, name, vec in axes:
        if name == 'z':
            z_axis = (rng, name, vec)
        else:
            other_axes.append((rng, name, vec))
    
    # v_vec should be the Z axis (vertical)
    # u_vec should be the largest of the remaining axes (horizontal)
    if z_axis:
        v_vec = z_axis[2]
        v_length = z_axis[0]
        
        # u_vec is the largest non-Z axis
        u_vec = other_axes[0][2]
        u_length = other_axes[0][0]
    else:
        # No Z variation? Wall is horizontal (unusual). Use the two largest.
        u_vec = axes[0][2]
        u_length = axes[0][0]
        v_vec = axes[1][2]
        v_length = axes[1][0]
    
    # Get face normal
    u_range = face.ParameterRange[:2]
    v_range = face.ParameterRange[2:]
    u_mid = (u_range[0] + u_range[1]) / 2
    v_mid = (v_range[0] + v_range[1]) / 2
    normal = face.normalAt(u_mid, v_mid)
    
    return origin, u_vec, v_vec, normal, u_length, v_length


def scale_vector(vec, scale):
    """Helper to scale a vector."""
    return App.Vector(vec.x * scale, vec.y * scale, vec.z * scale)


def create_brick_from_def(brick_def, origin, u_vec, v_vec, normal):
    """
    Create a FreeCAD brick solid from a brick definition.
    
    Constructs brick by building vertices in world space using wall coordinate vectors.
    This ensures correct positioning and orientation without matrix transformations.
    
    Args:
        brick_def: BrickDef with position, dimensions, and type
        origin: Wall origin point
        u_vec: Horizontal direction (left-right on wall, normalized)
        v_vec: Vertical direction (up-down on wall, normalized)
        normal: Wall normal (perpendicular out, normalized)
        
    Returns:
        Part.Shape: Brick solid
    """
    
    # Brick dimensions and position
    u_pos = brick_def.u
    v_pos = brick_def.v
    width = brick_def.width
    height = brick_def.height
    depth = brick_def.depth
    
    # Build 8 vertices in world space
    # Each vertex = origin + u_offset*u_vec + v_offset*v_vec + n_offset*normal
    
    # Near face (n=0)
    p0 = origin + scale_vector(u_vec, u_pos) + scale_vector(v_vec, v_pos)
    p1 = origin + scale_vector(u_vec, u_pos + width) + scale_vector(v_vec, v_pos)
    p2 = origin + scale_vector(u_vec, u_pos + width) + scale_vector(v_vec, v_pos + height)
    p3 = origin + scale_vector(u_vec, u_pos) + scale_vector(v_vec, v_pos + height)
    
    # Far face (n=depth)
    p4 = p0 + scale_vector(normal, depth)
    p5 = p1 + scale_vector(normal, depth)
    p6 = p2 + scale_vector(normal, depth)
    p7 = p3 + scale_vector(normal, depth)
    
    # Create the 12 edges
    e0 = Part.Edge(Part.LineSegment(p0, p1).toShape())
    e1 = Part.Edge(Part.LineSegment(p1, p2).toShape())
    e2 = Part.Edge(Part.LineSegment(p2, p3).toShape())
    e3 = Part.Edge(Part.LineSegment(p3, p0).toShape())
    
    e4 = Part.Edge(Part.LineSegment(p4, p5).toShape())
    e5 = Part.Edge(Part.LineSegment(p5, p6).toShape())
    e6 = Part.Edge(Part.LineSegment(p6, p7).toShape())
    e7 = Part.Edge(Part.LineSegment(p7, p4).toShape())
    
    e8 = Part.Edge(Part.LineSegment(p0, p4).toShape())
    e9 = Part.Edge(Part.LineSegment(p1, p5).toShape())
    e10 = Part.Edge(Part.LineSegment(p2, p6).toShape())
    e11 = Part.Edge(Part.LineSegment(p3, p7).toShape())
    
    # Create the 6 faces
    wire_near = Part.Wire([e0, e1, e2, e3])
    wire_far = Part.Wire([e4, e5, e6, e7])
    wire_bottom = Part.Wire([e0, e9, e4, e8])
    wire_top = Part.Wire([e2, e10, e6, e11])
    wire_left = Part.Wire([e3, e8, e7, e11])
    wire_right = Part.Wire([e1, e9, e5, e10])
    
    face_near = Part.Face(wire_near)
    face_far = Part.Face(wire_far)
    face_bottom = Part.Face(wire_bottom)
    face_top = Part.Face(wire_top)
    face_left = Part.Face(wire_left)
    face_right = Part.Face(wire_right)
    
    # Create shell and solid
    shell = Part.Shell([face_near, face_far, face_bottom, face_top, face_left, face_right])
    brick = Part.Solid(shell)
    
    return brick


def get_params_from_spreadsheet(doc):
    """Try to read parameters from spreadsheet."""
    params = {}
    
    try:
        ss = doc.getObject("Spreadsheet")
        if ss is None:
            return None
        
        param_map = {
            'brick_width': 'brickWidth',
            'brick_height': 'brickHeight',
            'brick_depth': 'brickDepth',
            'mortar': 'mortar',
            'bond_type': 'bondType',
            'common_bond_count': 'commonBondCount'
        }
        
        for param_key, cell_name in param_map.items():
            try:
                val = ss.get(cell_name)
                if val is not None:
                    if param_key in ['bond_type']:
                        params[param_key] = str(val)
                    else:
                        params[param_key] = float(val)
            except:
                continue
        
        return params if params else None
    except:
        return None


# ============================================================================
# MACRO EXECUTION
# ============================================================================

if __name__ == '__main__' or __name__ == '__console__' or __name__ == '__plugins__':
    doc = App.ActiveDocument
    
    if doc is None:
        print("ERROR: No active document. Please create or open a document first.")
    else:
        # Get selection
        selection = App.Gui.Selection.getSelectionEx()
        
        if not selection:
            print("ERROR: Please select a sketch or face to apply bricks to.")
        else:
            sel_obj = selection[0].Object
            obj_name = sel_obj.Label
            
            # Determine if this is a sketch or a face selection
            is_sketch = (sel_obj.TypeId == 'Sketcher::SketchObject')
            
            if is_sketch:
                # Sketch-based workflow
                sketch = sel_obj
                
                print(f"\n{'='*60}")
                print(f"Generating bricks for sketch: {obj_name}")
                print(f"{'='*60}")
                
                try:
                    # Get sketch outer wire (assumes sketch is closed)
                    if not hasattr(sketch, 'Shape') or len(sketch.Shape.Wires) == 0:
                        raise ValueError("Sketch has no valid wires")
                    
                    outer_wire = max(sketch.Shape.Wires, key=lambda w: abs(Part.Face(w).Area))
                    face = Part.Face(outer_wire)
                    
                    # Get face coordinate system
                    origin, u_vec, v_vec, normal, u_length, v_length = get_face_coordinate_system(face)
                    
                    # Get parameters
                    params = get_params_from_spreadsheet(doc)
                    if params is None:
                        params = {}
                    
                    # Fill in defaults
                    brick_width = params.get('brick_width', 2.32)
                    brick_height = params.get('brick_height', 0.65)
                    brick_depth = params.get('brick_depth', 1.09)
                    mortar = params.get('mortar', 0.11)
                    bond_type = params.get('bond_type', 'stretcher')
                    common_bond_count = int(params.get('common_bond_count', 5))
                    
                    print(f"Wall dimensions: {u_length:.1f} x {v_length:.1f} mm")
                    print(f"Brick: {brick_width} x {brick_height} x {brick_depth} mm")
                    print(f"Mortar: {mortar} mm")
                    print(f"Bond: {bond_type}")
                    if bond_type.lower() == 'common':
                        print(f"Common bond count: {common_bond_count}")
                    print()
                    
                    # Generate geometry
                    print("Generating geometry...")
                    bg = BrickGeometry(
                        u_length=u_length,
                        v_length=v_length,
                        brick_width=brick_width,
                        brick_height=brick_height,
                        brick_depth=brick_depth,
                        mortar=mortar,
                        bond_type=bond_type,
                        common_bond_count=common_bond_count
                    )
                    
                    result = bg.generate()
                    brick_defs = result['bricks']
                    metadata = result['metadata']
                    
                    print(f"Generated {len(brick_defs)} brick definitions")
                    print(f"Bond pattern: {metadata['bond_type']}")
                    print(f"Number of courses: {metadata['num_courses']}")
                    print()
                    
                    # Create FreeCAD objects
                    print("Creating FreeCAD geometry...")
                    brick_shapes = []
                    print(f"DEBUG: origin={origin}")
                    print(f"DEBUG: u_vec={u_vec}, v_vec={v_vec}, normal={normal}")
                    for i, brick_def in enumerate(brick_defs):
                        brick = create_brick_from_def(brick_def, origin, u_vec, v_vec, normal)
                        brick_shapes.append(brick)
                        
                        if (i + 1) % 100 == 0:
                            print(f"  Created {i+1}/{len(brick_defs)} bricks...")
                    
                    print(f"Creating compound of {len(brick_shapes)} bricks...")
                    result_shape = Part.Compound(brick_shapes)
                    print(f"✓ Compound created (instant, no fusing)")
                    
                    # Create result object
                    result_obj = doc.addObject("Part::Feature", f"BrickedWall_{obj_name}")
                    result_obj.Shape = result_shape
                    
                    # Add metadata
                    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator that created this")
                    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
                    result_obj.addProperty("App::PropertyString", "SourceObject", "Metadata", "Source object name")
                    result_obj.addProperty("App::PropertyString", "BondType", "Metadata", "Bond pattern used")
                    result_obj.addProperty("App::PropertyInteger", "BrickCount", "Metadata", "Number of bricks generated")
                    
                    result_obj.GeneratorName = "brick_generator"
                    result_obj.GeneratorVersion = "3.0.0"
                    result_obj.SourceObject = obj_name
                    result_obj.BondType = bond_type
                    result_obj.BrickCount = len(brick_defs)
                    
                    doc.recompute()
                    
                    print(f"\n✓ Created: {result_obj.Label}")
                    print(f"  Brick count: {len(brick_defs)}")
                    print(f"  Bond type: {bond_type}\n")
                    print(f"{'='*60}")
                    print("SUCCESS!")
                    print(f"{'='*60}")
                    
                except Exception as e:
                    print(f"\n{'='*60}")
                    print(f"ERROR: {e}")
                    print(f"{'='*60}")
                    import traceback
                    traceback.print_exc()
            
            elif selection[0].SubObjects:
                # Face-based workflow
                sub_element = selection[0].SubElementNames[0]
                face_index = int(sub_element.replace('Face', '')) - 1
                face = sel_obj.Shape.Faces[face_index]
                
                print(f"\n{'='*60}")
                print(f"Generating bricks for: {obj_name}")
                print(f"Selected: {sub_element}")
                print(f"{'='*60}\n")
                
                try:
                    # Get face coordinate system
                    origin, u_vec, v_vec, normal, u_length, v_length = get_face_coordinate_system(face)
                    
                    print(f"DEBUG: Coordinate system detected:")
                    print(f"  origin = {origin}")
                    print(f"  u_vec = {u_vec}")
                    print(f"  v_vec = {v_vec}")
                    print(f"  normal = {normal}")
                    print(f"  u_length = {u_length:.1f}, v_length = {v_length:.1f}")
                    print()
                    
                    # Get parameters
                    params = get_params_from_spreadsheet(doc)
                    if params is None:
                        params = {}
                    
                    # Fill in defaults
                    brick_width = params.get('brick_width', 2.32)
                    brick_height = params.get('brick_height', 0.65)
                    brick_depth = params.get('brick_depth', 1.09)
                    mortar = params.get('mortar', 0.11)
                    bond_type = params.get('bond_type', 'stretcher')
                    common_bond_count = int(params.get('common_bond_count', 5))
                    
                    print(f"Wall dimensions: {u_length:.1f} x {v_length:.1f} mm")
                    print(f"Brick: {brick_width} x {brick_height} x {brick_depth} mm")
                    print(f"Mortar: {mortar} mm")
                    print(f"Bond: {bond_type}")
                    if bond_type.lower() == 'common':
                        print(f"Common bond count: {common_bond_count}")
                    print()
                    
                    # Generate geometry
                    print("Generating geometry...")
                    bg = BrickGeometry(
                        u_length=u_length,
                        v_length=v_length,
                        brick_width=brick_width,
                        brick_height=brick_height,
                        brick_depth=brick_depth,
                        mortar=mortar,
                        bond_type=bond_type,
                        common_bond_count=common_bond_count
                    )
                    
                    result = bg.generate()
                    brick_defs = result['bricks']
                    metadata = result['metadata']
                    
                    print(f"Generated {len(brick_defs)} brick definitions")
                    print(f"Bond pattern: {metadata['bond_type']}")
                    print(f"Number of courses: {metadata['num_courses']}")
                    print()
                    
                    # Create FreeCAD objects
                    print("Creating FreeCAD geometry...")
                    brick_shapes = []
                    print(f"DEBUG: origin={origin}")
                    print(f"DEBUG: u_vec={u_vec}, v_vec={v_vec}, normal={normal}")
                    for i, brick_def in enumerate(brick_defs):
                        brick = create_brick_from_def(brick_def, origin, u_vec, v_vec, normal)
                        brick_shapes.append(brick)
                        
                        if (i + 1) % 100 == 0:
                            print(f"  Created {i+1}/{len(brick_defs)} bricks...")
                    
                    print(f"Creating compound of {len(brick_shapes)} bricks...")
                    result_shape = Part.Compound(brick_shapes)
                    print(f"✓ Compound created (instant, no fusing)")
                    
                    # Create result object
                    result_obj = doc.addObject("Part::Feature", f"BrickedWall_{obj_name}")
                    result_obj.Shape = result_shape
                    
                    # Add metadata
                    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator that created this")
                    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
                    result_obj.addProperty("App::PropertyString", "SourceObject", "Metadata", "Source object name")
                    result_obj.addProperty("App::PropertyString", "SourceFace", "Metadata", "Source face")
                    result_obj.addProperty("App::PropertyString", "BondType", "Metadata", "Bond pattern used")
                    result_obj.addProperty("App::PropertyInteger", "BrickCount", "Metadata", "Number of bricks generated")
                    
                    result_obj.GeneratorName = "brick_generator"
                    result_obj.GeneratorVersion = "3.0.0"
                    result_obj.SourceObject = obj_name
                    result_obj.SourceFace = sub_element
                    result_obj.BondType = bond_type
                    result_obj.BrickCount = len(brick_defs)
                    
                    doc.recompute()
                    
                    print(f"\n✓ Created: {result_obj.Label}")
                    print(f"  Brick count: {len(brick_defs)}")
                    print(f"  Bond type: {bond_type}\n")
                    print(f"{'='*60}")
                    print("SUCCESS!")
                    print(f"{'='*60}")
                    
                except Exception as e:
                    print(f"\n{'='*60}")
                    print(f"ERROR: {e}")
                    print(f"{'='*60}")
                    import traceback
                    traceback.print_exc()
            else:
                print("ERROR: Please select a sketch or face to apply bricks to.")
