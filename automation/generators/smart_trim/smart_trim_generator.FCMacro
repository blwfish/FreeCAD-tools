"""
Smart Trim Generator for FreeCAD v1.2.0

Applies parametric trim (corner boards, eave trim, gable trim) to wall faces.
Now includes advanced corner detection and automatic miter angle calculation.

WORKFLOW:
1. Select one or more faces where you want trim
2. Run this macro
3. Adjust parameters in the Trim object's spreadsheet
4. Recompute to update trim geometry

NEW IN v1.2.0:
- Integrated trim_geometry library for corner detection
- Automatic miter angle calculation for any polygon
- Support for both external and internal corners
- Beveled profile option

Author: Brian White
Version: 1.2.0
License: MIT
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
import Draft
import sys
from pathlib import Path

# Get the directory where this macro is located
MACRO_DIR = Path(__file__).parent
sys.path.insert(0, str(MACRO_DIR))

try:
    import trim_geometry as tg
except ImportError:
    App.Console.PrintError(
        "ERROR: Cannot find trim_geometry.py\n"
        "Make sure trim_geometry.py is in the same directory as this macro.\n"
    )
    raise

# ==============================================================================
# DEFAULT PARAMETERS
# ==============================================================================

DEFAULT_PARAMS = {
    'trim_width': 2.0,      # mm - how far trim extends from wall
    'trim_height': 5.0,     # mm - height of trim molding
    'trim_style': 'rectangular',  # 'rectangular' or 'beveled'
    'bevel_size': 0.5,      # mm - bevel size for beveled profile
    'version': '1.2.0',
}

# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

def create_parameter_spreadsheet(obj, params):
    """Create a spreadsheet with trim parameters."""
    ss = obj.Document.addObject('Spreadsheet::Sheet', f'{obj.Name}_Params')
    
    # Add parameters
    ss.set('A1', 'Parameter')
    ss.set('B1', 'Value')
    ss.set('C1', 'Description')
    
    row = 2
    for key, value in params.items():
        ss.set(f'A{row}', key)
        ss.set(f'B{row}', str(value))
        row += 1
    
    # Add descriptions
    ss.set('C2', 'mm - trim width perpendicular to wall')
    ss.set('C3', 'mm - trim height parallel to wall')
    ss.set('C4', 'rectangular or beveled')
    ss.set('C5', 'mm - bevel size (if beveled)')
    ss.set('C6', 'Generator version')
    
    # Make cells read-only except values
    ss.setStyle('A1:C1', 'bold', 'add')
    
    ss.recompute()
    return ss


def get_param_value(ss, param_name):
    """Get a parameter value from spreadsheet."""
    for row in range(2, 20):
        cell_name = ss.get(f'A{row}')
        if cell_name == param_name:
            value = ss.get(f'B{row}')
            # Try to convert to appropriate type
            try:
                if '.' in value:
                    return float(value)
                return int(value)
            except ValueError:
                return value
    return None


def create_trim_profile(params):
    """Create trim profile based on parameters."""
    width = params['trim_width']
    height = params['trim_height']
    style = params['trim_style']
    
    if style == 'beveled':
        bevel = params['bevel_size']
        return tg.create_beveled_profile(width, height, bevel)
    else:
        return tg.create_simple_rectangular_profile(width, height)


# ==============================================================================
# MAIN GENERATION FUNCTION
# ==============================================================================

def generate_trim(selected_faces, params):
    """
    Generate trim for selected faces.
    
    Args:
        selected_faces: List of Face objects
        params: Dictionary of parameters
        
    Returns:
        Compound of all trim pieces
    """
    print(f"\n{'='*72}")
    print("SMART TRIM GENERATOR v1.2.0")
    print(f"{'='*72}\n")
    
    all_trim_pieces = []
    
    # Create profile once
    profile = create_trim_profile(params)
    print(f"Trim profile: {params['trim_style']} "
          f"({params['trim_width']}mm × {params['trim_height']}mm)")
    
    # Process each selected face
    for i, face in enumerate(selected_faces, 1):
        print(f"\nProcessing face {i}/{len(selected_faces)}...")
        
        # Check face orientation - if corners are all internal, face might be reversed
        analysis = tg.analyze_face_for_trim(face)
        
        # If all corners are internal (270°), face is probably reversed
        if analysis['num_internal'] == analysis['num_corners'] and analysis['num_corners'] > 0:
            # Check if they're all ~270° (reversed face indicator)
            avg_angle = sum(c.angle for c in analysis['all_corners']) / len(analysis['all_corners'])
            if 260 < avg_angle < 280:
                print(f"  ⚠ Face appears reversed (all internal 270°), reversing...")
                face = face.reversed()
                # Re-analyze with corrected face
                analysis = tg.analyze_face_for_trim(face)
        
        print(f"  Detected {analysis['num_corners']} corners:")
        print(f"    - {analysis['num_external']} external (convex)")
        print(f"    - {analysis['num_internal']} internal (concave)")
        
        # Show corner details
        for j, corner in enumerate(analysis['all_corners'], 1):
            print(f"    Corner {j}: {corner.corner_type.value:8s} "
                  f"{corner.angle:6.1f}° (miter: {corner.miter_angle():5.1f}°)")
        
        # Generate trim for this face
        try:
            trim_pieces = tg.generate_trim_for_face(face, profile)
            all_trim_pieces.extend(trim_pieces)
            print(f"  ✓ Generated {len(trim_pieces)} trim segments")
        except Exception as e:
            print(f"  ✗ Error generating trim: {e}")
            import traceback
            traceback.print_exc()
    
    if not all_trim_pieces:
        raise RuntimeError("No trim pieces were generated")
    
    # Create compound
    compound = Part.makeCompound(all_trim_pieces)
    
    print(f"\n{'='*72}")
    print(f"✓ Trim generation complete: {len(all_trim_pieces)} total pieces")
    print(f"{'='*72}\n")
    
    return compound


# ==============================================================================
# MAIN MACRO ENTRY POINT
# ==============================================================================

def extract_base_face_from_clapboard(obj):
    """
    Extract the underlying wall face from a clapboard compound.
    
    Looks for the sketch that was used to generate the clapboards,
    then extracts its face.
    """
    # Check if object has BaseFeature (might be a PartDesign object)
    if hasattr(obj, 'BaseFeature') and obj.BaseFeature:
        base = obj.BaseFeature
        if hasattr(base, 'Shape'):
            # Return the largest face (should be the wall)
            faces = base.Shape.Faces
            if faces:
                return max(faces, key=lambda f: f.Area)
    
    # Check if object has a Sketch property
    if hasattr(obj, 'Sketch') and obj.Sketch:
        sketch = obj.Sketch
        if hasattr(sketch, 'Shape'):
            faces = sketch.Shape.Faces
            if faces:
                return faces[0]  # Sketch should have one face
    
    # Check if object has dependencies (might reference a sketch)
    if hasattr(obj, 'InList'):
        for parent in obj.InList:
            if parent.TypeId == 'Sketcher::SketchObject':
                if hasattr(parent, 'Shape'):
                    faces = parent.Shape.Faces
                    if faces:
                        return faces[0]
    
    # Last resort: return the largest planar face from the compound
    if hasattr(obj, 'Shape') and obj.Shape.Faces:
        # Filter for large, planar faces (likely walls, not trim details)
        planar_faces = []
        for face in obj.Shape.Faces:
            try:
                if face.Surface.TypeId == 'Part::GeomPlane':
                    planar_faces.append(face)
            except:
                pass
        
        if planar_faces:
            # Return largest planar face
            return max(planar_faces, key=lambda f: f.Area)
    
    return None


def main():
    """Main macro entry point."""
    
    # Get selection
    sel = Gui.Selection.getSelectionEx()
    
    if not sel:
        App.Console.PrintError("No objects selected! Please select clapboard object or wall face.\n")
        return
    
    # Debug: show what we got
    print(f"\n=== Selection Debug ===")
    print(f"Number of selected objects: {len(sel)}")
    
    # Collect all selected faces
    selected_faces = []
    for i, sel_obj in enumerate(sel):
        print(f"\nSelection {i+1}:")
        print(f"  Object: {sel_obj.Object.Label if sel_obj.Object else 'None'}")
        print(f"  HasSubObjects: {sel_obj.HasSubObjects}")
        
        if sel_obj.HasSubObjects:
            # User selected a specific sub-object (face, edge, etc.)
            print(f"  SubObjects: {len(sel_obj.SubObjects)}")
            for j, sub_obj in enumerate(sel_obj.SubObjects):
                print(f"    SubObject {j+1}: {sub_obj.ShapeType}")
                if sub_obj.ShapeType == "Face":
                    selected_faces.append(sub_obj)
                    print(f"      ✓ Added face")
        else:
            # Whole object selected - extract base face
            obj = sel_obj.Object
            print(f"  Object type: {obj.TypeId if hasattr(obj, 'TypeId') else 'Unknown'}")
            print(f"  Has Shape: {hasattr(obj, 'Shape')}")
            
            # Try to extract base face from clapboard compound
            base_face = extract_base_face_from_clapboard(obj)
            
            if base_face:
                print(f"  ✓ Extracted wall face from {obj.Label}")
                selected_faces.append(base_face)
            elif hasattr(obj, 'Shape'):
                # Fall back to all faces
                num_faces = len(obj.Shape.Faces)
                print(f"  Fallback: found {num_faces} faces in shape")
                for face in obj.Shape.Faces:
                    selected_faces.append(face)
                    print(f"    ✓ Added face (Area: {face.Area:.2f})")
    
    print(f"\n=== Total faces collected: {len(selected_faces)} ===\n")
    
    if not selected_faces:
        App.Console.PrintError("No faces found in selection!\n")
        return
    
    print(f"Selected {len(selected_faces)} face(s)")
    
    # Get or create document
    doc = App.ActiveDocument
    if not doc:
        doc = App.newDocument("TrimProject")
    
    # Generate trim with default parameters
    try:
        trim_compound = generate_trim(selected_faces, DEFAULT_PARAMS)
    except Exception as e:
        App.Console.PrintError(f"Error generating trim: {e}\n")
        import traceback
        traceback.print_exc()
        return
    
    # Create FreeCAD object
    trim_obj = doc.addObject("Part::Feature", "Trim")
    trim_obj.Shape = trim_compound
    trim_obj.ViewObject.ShapeColor = (0.8, 0.6, 0.4)  # Wood color
    
    # Create parameter spreadsheet
    params_ss = create_parameter_spreadsheet(trim_obj, DEFAULT_PARAMS)
    
    # Link to group if we want organization
    # (Could add group creation here)
    
    doc.recompute()
    
    App.Console.PrintMessage("\n✓ Smart Trim object created successfully!\n")
    App.Console.PrintMessage(f"  Adjust parameters in '{params_ss.Name}' and recompute.\n\n")
    
    # Fit view
    Gui.SendMsgToActiveView("ViewFit")


# Run the macro
if __name__ == '__main__':
    main()
