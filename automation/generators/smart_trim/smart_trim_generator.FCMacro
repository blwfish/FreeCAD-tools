"""
Smart Trim Generator for FreeCAD v1.1.0

Applies parametric trim (corner boards, eave trim, gable trim) to wall faces
that have been decorated with clapboard or shingles.

Author: Generated for model railroading (HO/O/N scale)
Usage: Select a clapboard or shingle object, then run this macro

Version History:
- 1.1.0: IMPROVEMENT: Handle PropertyLink for SourceObject (clapboard v5.3.0+, shingle v4.1.0+)
         BACKWARD COMPAT: Still supports old PropertyString format (auto-detected)
         If SourceObject is PropertyLink: direct object reference (more robust)
         If SourceObject is PropertyString: label lookup (legacy objects)
- 1.0.9: Fixed outward direction for source clapboards
         - Clapboard geometry extends on BOTH sides of face (mostly into wall)
         - Now checks which direction clapboard extends BEYOND the face
         - The side that protrudes past the face is the outward direction
- 1.0.8: Fixed outward direction detection for all cases
- 1.0.7: Rewrote outward direction detection
- 1.0.6: Fixed mirror normal direction
- 1.0.5: Fixed two critical issues
- 1.0.3: Fixed edge detection to analyze source wall face
- 1.0.2: Added punchout hole detection
- 1.0.1: Fixed mirror support
- 1.0.0: Initial release
"""

import FreeCAD as App
import Part
from FreeCAD import Vector
import math
import sys

VERSION = "1.1.0"
GENERATOR_NAME = "smart_trim_generator"

# Import the geometry library
try:
    import sys
    from pathlib import Path
    
    # FreeCAD user macro directory
    macro_base = Path.home() / "Library" / "Application Support" / "FreeCAD" / "Macro"
    lib_dir = macro_base / "_lib"
    
    # Remove any old instances from sys.modules to force fresh import
    if 'smart_trim_geometry' in sys.modules:
        del sys.modules['smart_trim_geometry']
    
    # Add to path if not already there
    lib_dir_str = str(lib_dir)
    if lib_dir_str not in sys.path:
        sys.path.insert(0, lib_dir_str)
    
    print(f"Loading from: {lib_dir_str}")
    
    from smart_trim_geometry import (
        classify_edges,
        get_edge_length,
        validate_trim_parameters,
    )
    print(f"✓ Loaded smart_trim_geometry library")
except ImportError as e:
    App.Console.PrintError(f"ERROR: Could not import smart_trim_geometry: {e}\n")
    App.Console.PrintError(f"Expected location: {lib_dir}/smart_trim_geometry.py\n")
    sys.exit(1)


def find_spreadsheet(doc, preferred_names):
    """Find spreadsheet by checking both object name and label."""
    for ss_name in preferred_names:
        obj = doc.getObject(ss_name)
        if obj and obj.TypeId == 'Spreadsheet::Sheet':
            print(f"Found spreadsheet by name: '{ss_name}'")
            return obj
        
        for obj in doc.Objects:
            if obj.TypeId == 'Spreadsheet::Sheet' and obj.Label == ss_name:
                print(f"Found spreadsheet by label: '{ss_name}' (object name: '{obj.Name}')")
                return obj
    
    return None


def get_params_from_spreadsheet(doc):
    """Try to read trim parameters from spreadsheet."""
    preferred_names = ["params", "TrimParameters", "BuildingParameters", "Spreadsheet"]
    
    ss = find_spreadsheet(doc, preferred_names)
    if ss is None:
        return None
    
    params = {}
    param_map = {
        'trim_width': ['trim_width', 'TrimWidth', 'trimWidth'],
        'trim_thickness': ['trim_thickness', 'TrimThickness', 'thickness'],
    }
    
    for param_key, possible_names in param_map.items():
        for name in possible_names:
            try:
                val = ss.get(name)
                if val is not None:
                    params[param_key] = float(val)
                    break
            except:
                continue
    
    return params if params else None


def parse_clapboard_name(obj_name):
    """Parse clapboard object name to extract source object and face index."""
    if obj_name.startswith("ClapboardWall_"):
        parts = obj_name.split("_F")
        if len(parts) == 2:
            try:
                face_index = int(parts[1])
                source_name = parts[0].replace("ClapboardWall_", "")
                return (source_name, face_index)
            except ValueError:
                return None
    
    if obj_name.startswith("ShingledRoof_"):
        source_name = obj_name.replace("ShingledRoof_", "")
        return (source_name, None)
    
    return None


def get_source_object_and_face(doc, trim_source_obj):
    """
    Derive the source wall object and face from a clapboard/shingle object.
    
    v1.1.0 IMPROVEMENT: Now handles both PropertyLink (v5.3.0+) and PropertyString (legacy)
    
    Args:
        doc: FreeCAD document
        trim_source_obj: The clapboard or shingle object selected by user (may be a mirror)
    
    Returns:
        Tuple of (source_object, face_index, clapboard_obj) or raises ValueError
    """
    # Handle Part::Mirroring objects
    print(f"DEBUG: trim_source_obj.TypeId = '{trim_source_obj.TypeId}'")
    print(f"DEBUG: TypeId == 'Part::Mirroring' = {trim_source_obj.TypeId == 'Part::Mirroring'}")
    print(f"DEBUG: hasattr Source = {hasattr(trim_source_obj, 'Source')}")
    
    if trim_source_obj.TypeId == 'Part::Mirroring' and hasattr(trim_source_obj, 'Source'):
        print(f"DEBUG: Detected Part::Mirroring, reading from Source object")
        clapboard_obj = trim_source_obj.Source
        print(f"DEBUG: clapboard_obj.Name = '{clapboard_obj.Name}'")
    else:
        print(f"DEBUG: NOT detected as Part::Mirroring, using trim_source_obj directly")
        clapboard_obj = trim_source_obj
        print(f"DEBUG: clapboard_obj.Name = '{clapboard_obj.Name}'")
    
    print(f"DEBUG: About to check for SourceObject property on '{clapboard_obj.Name}'")
    
    # v1.1.0: Handle both PropertyLink (new) and PropertyString (legacy)
    if hasattr(clapboard_obj, 'SourceObject'):
        source_object_value = clapboard_obj.SourceObject
        
        # Detect property type: PropertyLink or PropertyString
        # PropertyLink: value is an object reference (FreeCAD object)
        # PropertyString: value is a string (label)
        
        if isinstance(source_object_value, str):
            # OLD FORMAT: PropertyString - value is a label string
            source_label = source_object_value
            print(f"Found SourceObject property (PropertyString): {source_label}")
            
            # Look up by label
            source_obj = None
            for obj in doc.Objects:
                if obj.Label == source_label:
                    source_obj = obj
                    break
            
            if source_obj is None:
                raise ValueError(
                    f"Source object '{source_label}' (from property) not found in document"
                )
        else:
            # NEW FORMAT: PropertyLink - value is already an object reference
            # This is the recommended format (clapboard v5.3.0+, shingle v4.1.0+)
            source_obj = source_object_value
            print(f"Found SourceObject property (PropertyLink): {source_obj.Label if source_obj else 'None'}")
            
            if source_obj is None:
                raise ValueError(
                    f"SourceObject property is None (property exists but is unset)"
                )
    else:
        # Fallback: try to parse from object name
        parse_result = parse_clapboard_name(clapboard_obj.Name)
        
        if parse_result is None:
            raise ValueError(
                f"Could not parse source object from '{clapboard_obj.Name}'\n"
                f"Expected format: ClapboardWall_<SourceObject>_F<FaceIndex>\n"
                f"(or object should have SourceObject property)"
            )
        
        source_name, face_index = parse_result
        
        # Look up source object in document
        source_obj = doc.getObject(source_name)
        if source_obj is None:
            raise ValueError(
                f"Source object '{source_name}' not found in document\n"
                f"(derived from '{clapboard_obj.Name}')"
            )
    
    if not hasattr(source_obj, 'Shape'):
        raise ValueError(
            f"Source object '{source_obj.Label}' has no Shape property"
        )
    
    # Get face index from FaceIndex property
    if hasattr(clapboard_obj, 'FaceIndex'):
        face_index = clapboard_obj.FaceIndex
        print(f"Found FaceIndex property: {face_index}")
    else:
        # Fallback: try to parse from name
        parse_result = parse_clapboard_name(clapboard_obj.Name)
        if parse_result is None or parse_result[1] is None:
            raise ValueError(
                f"Could not extract face index from '{clapboard_obj.Name}'\n"
                f"(or object should have FaceIndex property)"
            )
        face_index = parse_result[1]
    
    if face_index >= len(source_obj.Shape.Faces):
        raise ValueError(
            f"Face index {face_index} out of range for '{source_obj.Label}'\n"
            f"(object has {len(source_obj.Shape.Faces)} faces)"
        )
    
    return source_obj, face_index, clapboard_obj


def get_face_edges(face):
    """Extract edges from a face's outer wire."""
    wires = face.Wires
    if not wires:
        raise ValueError("Face has no wires!")
    
    outer_wire = max(wires, key=lambda w: abs(Part.Face(w).Area))
    
    edges = []
    for edge in outer_wire.Edges:
        start = edge.valueAt(edge.FirstParameter)
        end = edge.valueAt(edge.LastParameter)
        
        edges.append({
            'start': (start.x, start.y, start.z),
            'end': (end.x, end.y, end.z),
            'edge_obj': edge,
            'length': edge.Length,
        })
    
    return edges


def point_on_bbox_boundary(point, bbox, tolerance=0.01):
    """Check if a point is on the boundary of a bounding box."""
    x, y, z = point
    
    on_xmin = abs(x - bbox.XMin) < tolerance
    on_xmax = abs(x - bbox.XMax) < tolerance
    on_ymin = abs(y - bbox.YMin) < tolerance
    on_ymax = abs(y - bbox.YMax) < tolerance
    on_zmin = abs(z - bbox.ZMin) < tolerance
    on_zmax = abs(z - bbox.ZMax) < tolerance
    
    return on_xmin or on_xmax or on_ymin or on_ymax or on_zmin or on_zmax


def detect_punchout_misalignment(edges, bbox, tolerance=0.01):
    """Detect if any edges indicate a punchout misalignment."""
    problem_edges = []
    
    for i, edge in enumerate(edges):
        start_on_boundary = point_on_bbox_boundary(edge['start'], bbox, tolerance)
        end_on_boundary = point_on_bbox_boundary(edge['end'], bbox, tolerance)
        
        if start_on_boundary != end_on_boundary:
            problem_edges.append(i)
    
    return len(problem_edges) > 0, problem_edges


def classify_edge_location(edge, bbox, tolerance=0.01):
    """Classify an edge as 'boundary' or 'interior'."""
    start_on_boundary = point_on_bbox_boundary(edge['start'], bbox, tolerance)
    end_on_boundary = point_on_bbox_boundary(edge['end'], bbox, tolerance)
    
    if start_on_boundary and end_on_boundary:
        return 'boundary'
    else:
        return 'interior'


def is_perimeter_edge(edge_obj, bbox, normal_axis, tolerance=0.1):
    """Check if an edge lies on the outer perimeter of the face bounding box."""
    start = edge_obj.valueAt(edge_obj.FirstParameter)
    end = edge_obj.valueAt(edge_obj.LastParameter)
    
    if normal_axis == 'x':
        at_ymin = abs(start.y - bbox.YMin) < tolerance and abs(end.y - bbox.YMin) < tolerance
        at_ymax = abs(start.y - bbox.YMax) < tolerance and abs(end.y - bbox.YMax) < tolerance
        at_zmin = abs(start.z - bbox.ZMin) < tolerance and abs(end.z - bbox.ZMin) < tolerance
        at_zmax = abs(start.z - bbox.ZMax) < tolerance and abs(end.z - bbox.ZMax) < tolerance
        return at_ymin or at_ymax or at_zmin or at_zmax
    
    elif normal_axis == 'y':
        at_xmin = abs(start.x - bbox.XMin) < tolerance and abs(end.x - bbox.XMin) < tolerance
        at_xmax = abs(start.x - bbox.XMax) < tolerance and abs(end.x - bbox.XMax) < tolerance
        at_zmin = abs(start.z - bbox.ZMin) < tolerance and abs(end.z - bbox.ZMin) < tolerance
        at_zmax = abs(start.z - bbox.ZMax) < tolerance and abs(end.z - bbox.ZMax) < tolerance
        return at_xmin or at_xmax or at_zmin or at_zmax
    
    else:  # normal_axis == 'z'
        at_xmin = abs(start.x - bbox.XMin) < tolerance and abs(end.x - bbox.XMin) < tolerance
        at_xmax = abs(start.x - bbox.XMax) < tolerance and abs(end.x - bbox.XMax) < tolerance
        at_ymin = abs(start.y - bbox.YMin) < tolerance and abs(end.y - bbox.YMin) < tolerance
        at_ymax = abs(start.y - bbox.YMax) < tolerance and abs(end.y - bbox.YMax) < tolerance
        return at_xmin or at_xmax or at_ymin or at_ymax


def detect_face_orientation(bbox):
    """Detect which plane a face lies in based on bounding box extents."""
    x_extent = bbox.XMax - bbox.XMin
    y_extent = bbox.YMax - bbox.YMin
    z_extent = bbox.ZMax - bbox.ZMin
    
    tolerance = 0.1
    
    if x_extent < tolerance:
        return 'z', 'y', 'x'
    elif y_extent < tolerance:
        return 'z', 'x', 'y'
    elif z_extent < tolerance:
        return 'y', 'x', 'z'
    else:
        if z_extent >= y_extent and z_extent >= x_extent:
            if x_extent > y_extent:
                return 'z', 'x', 'y'
            else:
                return 'z', 'y', 'x'
        else:
            return 'y', 'x', 'z'


def create_trim_along_edge(edge, vertical_axis, normal_direction, 
                           trim_width, trim_thickness):
    """Create trim geometry along a single edge."""
    start = edge.valueAt(edge.FirstParameter)
    end = edge.valueAt(edge.LastParameter)
    edge_length = edge.Length
    
    if edge_length < 0.001:
        return None
    
    edge_dir = (end - start)
    edge_dir.normalize()
    
    width_dir = edge_dir.cross(normal_direction)
    width_dir.normalize()
    
    v1 = start
    v2 = start + (normal_direction * trim_thickness)
    v5 = v1 - (width_dir * trim_width)
    v6 = v2 - (width_dir * trim_width)
    
    v4 = end
    v3 = end + (normal_direction * trim_thickness)
    v8 = v4 - (width_dir * trim_width)
    v7 = v3 - (width_dir * trim_width)
    
    try:
        back_face = Part.Face(Part.makePolygon([v1, v4, v8, v5, v1]))
        front_face = Part.Face(Part.makePolygon([v2, v3, v7, v6, v2]))
        bottom_face = Part.Face(Part.makePolygon([v1, v2, v3, v4, v1]))
        top_face = Part.Face(Part.makePolygon([v5, v6, v7, v8, v5]))
        start_face = Part.Face(Part.makePolygon([v1, v5, v6, v2, v1]))
        end_face = Part.Face(Part.makePolygon([v4, v3, v7, v8, v4]))
        
        shell = Part.Shell([back_face, front_face, bottom_face, top_face, start_face, end_face])
        trim_solid = Part.Solid(shell)
        
        return trim_solid
    except Exception as e:
        print(f"    Warning: Could not create trim solid: {e}")
        try:
            front_wire = Part.makePolygon([v2, v3, v7, v6, v2])
            front_face = Part.Face(front_wire)
            return front_face
        except:
            return None


def generate_trim(clapboard_obj, face_index, trim_width=2.0, trim_thickness=1.0, 
                  selected_obj=None):
    """Generate corner, eave, and gable trim for a clapboard face."""
    is_mirror = (selected_obj is not None and selected_obj.TypeId == 'Part::Mirroring')
    print(f"\nGenerating smart trim for face {face_index}...")
    
    if not hasattr(clapboard_obj, 'SourceObject'):
        raise ValueError(f"Clapboard object missing SourceObject property")
    
    import FreeCAD as App
    doc = App.ActiveDocument
    
    # v1.1.0: Handle both PropertyLink and PropertyString
    source_object_value = clapboard_obj.SourceObject
    if isinstance(source_object_value, str):
        source_wall_label = source_object_value
        source_wall = None
        for obj in doc.Objects:
            if obj.Label == source_wall_label:
                source_wall = obj
                break
        if source_wall is None:
            raise ValueError(f"Source wall '{source_wall_label}' not found")
    else:
        source_wall = source_object_value
        if source_wall is None:
            raise ValueError(f"SourceObject property is None")
    
    if face_index >= len(source_wall.Shape.Faces):
        raise ValueError(f"Face index {face_index} out of range for source wall")
    
    face = source_wall.Shape.Faces[face_index]
    print(f"Analyzing source wall face: {source_wall.Label}, face {face_index}")
    print(f"  Face area: {face.Area:.2f} mm², wires: {len(face.Wires)}")
    
    bbox = face.BoundBox
    vertical_axis, horizontal_axis, normal_axis = detect_face_orientation(bbox)
    
    print(f"Face orientation: vertical={vertical_axis}, horizontal={horizontal_axis}")
    
    from FreeCAD import Vector
    
    face_bbox = face.BoundBox
    source_clapboard_bbox = clapboard_obj.Shape.BoundBox
    
    if normal_axis == 'x':
        face_x = (face_bbox.XMin + face_bbox.XMax) / 2
        extend_positive = source_clapboard_bbox.XMax - face_x
        extend_negative = face_x - source_clapboard_bbox.XMin
        if extend_positive > 0.01:
            outward_sign = 1.0
        elif extend_negative > 0.01:
            outward_sign = -1.0
        else:
            outward_sign = 1.0 if extend_positive > extend_negative else -1.0
        face_normal = Vector(outward_sign, 0, 0)
        print(f"Source face at X={face_x:.2f}, clapboard X range: {source_clapboard_bbox.XMin:.2f} to {source_clapboard_bbox.XMax:.2f}")
        print(f"Extends beyond face: +X by {extend_positive:.2f}, -X by {extend_negative:.2f}")
        print(f"Outward direction: {'positive' if outward_sign > 0 else 'negative'} X")
        
    elif normal_axis == 'y':
        face_y = (face_bbox.YMin + face_bbox.YMax) / 2
        extend_positive = source_clapboard_bbox.YMax - face_y
        extend_negative = face_y - source_clapboard_bbox.YMin
        if extend_positive > 0.01:
            outward_sign = 1.0
        elif extend_negative > 0.01:
            outward_sign = -1.0
        else:
            outward_sign = 1.0 if extend_positive > extend_negative else -1.0
        face_normal = Vector(0, outward_sign, 0)
        print(f"Source face at Y={face_y:.2f}, clapboard Y range: {source_clapboard_bbox.YMin:.2f} to {source_clapboard_bbox.YMax:.2f}")
        print(f"Extends beyond face: +Y by {extend_positive:.2f}, -Y by {extend_negative:.2f}")
        print(f"Outward direction: {'positive' if outward_sign > 0 else 'negative'} Y")
        
    else:  # normal_axis == 'z'
        face_z = (face_bbox.ZMin + face_bbox.ZMax) / 2
        extend_positive = source_clapboard_bbox.ZMax - face_z
        extend_negative = face_z - source_clapboard_bbox.ZMin
        if extend_positive > 0.01:
            outward_sign = 1.0
        elif extend_negative > 0.01:
            outward_sign = -1.0
        else:
            outward_sign = 1.0 if extend_positive > extend_negative else -1.0
        face_normal = Vector(0, 0, outward_sign)
        print(f"Source face at Z={face_z:.2f}, clapboard Z range: {source_clapboard_bbox.ZMin:.2f} to {source_clapboard_bbox.ZMax:.2f}")
        print(f"Extends beyond face: +Z by {extend_positive:.2f}, -Z by {extend_negative:.2f}")
        print(f"Outward direction: {'positive' if outward_sign > 0 else 'negative'} Z")
    
    print(f"Face normal for trim: ({face_normal.x:.3f}, {face_normal.y:.3f}, {face_normal.z:.3f})")
    
    edges = get_face_edges(face)
    print(f"Found {len(edges)} edges")
    
    has_misalignment, problem_edges = detect_punchout_misalignment(edges, bbox)
    
    if has_misalignment:
        raise ValueError(
            f"⚠️  PUNCHOUT MISALIGNMENT DETECTED!\n"
            f"   Face has {len(problem_edges)} edge(s) that cross the wall boundary.\n"
            f"   This suggests a boolean cut (window/door punchout) doesn't align\n"
            f"   properly with the wall edge.\n"
            f"   Problem edge indices: {problem_edges}\n"
            f"   Please fix the punchout geometry and re-run smart trim.\n"
        )
    
    classifications = classify_edges(edges, vertical_axis=vertical_axis, angle_tolerance=5.0)
    
    print(f"  Checking edges against bbox perimeter (normal_axis={normal_axis})...")
    
    corner_trim_parts = []
    eave_trim_parts = []
    gable_trim_parts = []
    
    for edge_idx, classification in classifications:
        edge_dict = edges[edge_idx]
        edge = edge_dict['edge_obj']
        
        is_perim = is_perimeter_edge(edge, bbox, normal_axis, tolerance=0.1)
        
        if not is_perim:
            print(f"  Edge {edge_idx}: SKIPPED (notch/hole edge) - length {edge.Length:.2f}mm")
            continue
        
        start = edge.valueAt(edge.FirstParameter)
        end = edge.valueAt(edge.LastParameter)
        
        if vertical_axis == 'z':
            at_bottom = abs(start.z - bbox.ZMin) < 0.1 and abs(end.z - bbox.ZMin) < 0.1
        elif vertical_axis == 'y':
            at_bottom = abs(start.y - bbox.YMin) < 0.1 and abs(end.y - bbox.YMin) < 0.1
        else:  # 'x'
            at_bottom = abs(start.x - bbox.XMin) < 0.1 and abs(end.x - bbox.XMin) < 0.1
        
        if at_bottom:
            print(f"  Edge {edge_idx}: SKIPPED (bottom edge) - length {edge.Length:.2f}mm")
            continue
        
        if classification == 'vertical':
            print(f"  Edge {edge_idx}: VERTICAL (corner trim) - length {edge.Length:.2f}mm")
            try:
                trim = create_trim_along_edge(edge, vertical_axis, face_normal, 
                                             trim_width, trim_thickness)
                if trim:
                    corner_trim_parts.append(trim)
            except Exception as e:
                print(f"    Warning: Failed to create corner trim: {e}")
        
        elif classification == 'horizontal':
            print(f"  Edge {edge_idx}: HORIZONTAL (eave trim) - length {edge.Length:.2f}mm")
            try:
                trim = create_trim_along_edge(edge, vertical_axis, face_normal,
                                             trim_width, trim_thickness)
                if trim:
                    eave_trim_parts.append(trim)
            except Exception as e:
                print(f"    Warning: Failed to create eave trim: {e}")
        
        elif classification == 'gable':
            print(f"  Edge {edge_idx}: GABLE (diagonal) - length {edge.Length:.2f}mm")
            try:
                trim = create_trim_along_edge(edge, vertical_axis, face_normal,
                                             trim_width, trim_thickness)
                if trim:
                    gable_trim_parts.append(trim)
            except Exception as e:
                print(f"    Warning: Failed to create gable trim: {e}")
    
    corner_trim = None
    eave_trim = None
    gable_trim = None
    
    if corner_trim_parts:
        print(f"\nFusing {len(corner_trim_parts)} corner trim parts...")
        corner_trim = corner_trim_parts[0]
        for part in corner_trim_parts[1:]:
            try:
                corner_trim = corner_trim.fuse(part)
            except Exception as e:
                print(f"  Warning: Fuse failed: {e}")
    
    if eave_trim_parts:
        print(f"Fusing {len(eave_trim_parts)} eave trim parts...")
        eave_trim = eave_trim_parts[0]
        for part in eave_trim_parts[1:]:
            try:
                eave_trim = eave_trim.fuse(part)
            except Exception as e:
                print(f"  Warning: Fuse failed: {e}")
    
    if gable_trim_parts:
        print(f"Fusing {len(gable_trim_parts)} gable trim parts...")
        gable_trim = gable_trim_parts[0]
        for part in gable_trim_parts[1:]:
            try:
                gable_trim = gable_trim.fuse(part)
            except Exception as e:
                print(f"  Warning: Fuse failed: {e}")
    
    if selected_obj is not None and selected_obj.TypeId == 'Part::Mirroring':
        mirror_base = selected_obj.Base
        mirror_normal = selected_obj.Normal
        print(f"\nApplying mirror transformation...")
        
        if corner_trim:
            corner_trim = corner_trim.mirror(mirror_base, mirror_normal)
        if eave_trim:
            eave_trim = eave_trim.mirror(mirror_base, mirror_normal)
        if gable_trim:
            gable_trim = gable_trim.mirror(mirror_base, mirror_normal)
    
    return corner_trim, eave_trim, gable_trim


if __name__ == '__main__' or __name__ == '__console__' or __name__ == '__plugins__':
    doc = App.activeDocument()
    if doc is None:
        App.Console.PrintError("No active document!\n")
    else:
        try:
            import FreeCADGui
            selection_ex = FreeCADGui.Selection.getSelectionEx()
            
            if len(selection_ex) == 0:
                App.Console.PrintError("No object selected!\n")
                App.Console.PrintError("Please select one or more clapboard or shingle objects.\n")
            else:
                if len(selection_ex) > 1:
                    App.Console.PrintMessage(f"\n=== Processing {len(selection_ex)} objects ===\n")
                
                params = get_params_from_spreadsheet(doc)
                
                if params:
                    trim_width = params.get('trim_width', 2.0)
                    trim_thickness = params.get('trim_thickness', 1.0)
                    print(f"Using parameters from spreadsheet")
                else:
                    trim_width = 2.0
                    trim_thickness = 1.0
                    print(f"Using HO scale defaults")
                
                print(f"Trim width: {trim_width}mm, thickness: {trim_thickness}mm")
                
                success_count = 0
                fail_count = 0
                
                for sel_obj in selection_ex:
                    selected_obj = sel_obj.Object
                    
                    print(f"\n{'='*72}")
                    print(f"  Smart Trim Generator v{VERSION}")
                    print(f"{'='*72}")
                    print(f"\nSelected: {selected_obj.Label}")
                    
                    try:
                        source_obj, face_index, clapboard_obj = get_source_object_and_face(doc, selected_obj)
                        print(f"Source object: {source_obj.Label}")
                        print(f"Face index: {face_index}")
                        print(f"Clapboard object: {clapboard_obj.Label}")
                    except ValueError as e:
                        App.Console.PrintError(f"Error: {e}\n")
                        fail_count += 1
                        continue
                    
                    is_valid, errors = validate_trim_parameters(trim_width, trim_thickness)
                    if not is_valid:
                        for error in errors:
                            App.Console.PrintError(f"  {error}\n")
                        fail_count += 1
                        continue
                    
                    try:
                        corner_trim, eave_trim, gable_trim = generate_trim(
                            clapboard_obj, face_index, trim_width, trim_thickness,
                            selected_obj=selected_obj
                        )
                        
                        compound_parts = []
                        
                        if corner_trim:
                            corner_obj = doc.addObject("Part::Feature",
                                                       f"SmartTrim_{selected_obj.Name}_Vertical")
                            corner_obj.Shape = corner_trim
                            compound_parts.append(corner_obj)
                            print(f"\n✓ Created: {corner_obj.Label}")
                        
                        if eave_trim:
                            eave_obj = doc.addObject("Part::Feature",
                                                     f"SmartTrim_{selected_obj.Name}_Eave")
                            eave_obj.Shape = eave_trim
                            compound_parts.append(eave_obj)
                            print(f"✓ Created: {eave_obj.Label}")
                        
                        if gable_trim:
                            gable_obj = doc.addObject("Part::Feature",
                                                      f"SmartTrim_{selected_obj.Name}_Gable")
                            gable_obj.Shape = gable_trim
                            compound_parts.append(gable_obj)
                            print(f"✓ Created: {gable_obj.Label}")
                        
                        if not compound_parts:
                            App.Console.PrintWarning("No trim parts generated!\n")
                            fail_count += 1
                        else:
                            compound = doc.addObject("Part::Compound",
                                                    f"SmartTrim_{selected_obj.Name}")
                            compound.Links = compound_parts
                            print(f"\n✓ Created compound: {compound.Label}")
                            print(f"  ({len(compound_parts)} trim components)")
                            success_count += 1
                        
                    except Exception as e:
                        App.Console.PrintError(f"Error generating trim: {e}\n")
                        import traceback
                        traceback.print_exc()
                        fail_count += 1
                
                doc.recompute()
                
                if len(selection_ex) > 1:
                    App.Console.PrintMessage(f"\n=== SUMMARY: {success_count} succeeded, {fail_count} failed ===\n")
        
        except Exception as e:
            App.Console.PrintError(f"Unexpected error: {e}\n")
            import traceback
            traceback.print_exc()
