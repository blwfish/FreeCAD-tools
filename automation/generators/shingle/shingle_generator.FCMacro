"""
Parametric Shingle Generator for FreeCAD v5.0.0
Generates realistic shingles on roof surfaces from selected faces

Author: Brian (with Claude assistance)
Usage: Select one or more roof faces, run as macro in FreeCAD

Version History:
- 5.0.0: MAJOR: Bounding-box based orientation detection replaces normal-based approach.
         Uses vertex Z coordinates to find eave (lowest) and ridge (highest), then
         calculates V-direction as eave→ridge. This is geometrically unambiguous and
         works correctly on symmetric gable roofs where normal-based detection failed.
         Also adds Z-based valley/ridge detection for smart trim functionality.
         Smart trim now reliably distinguishes valleys from ridges by checking if
         non-shared vertices are above or below the shared edge.
- 4.3.3: BUG FIX: Correct normal orientation detection using dot product with V-vector.
         Previously used simple normal.z > 0 check, which failed on symmetric gable roofs
         where both faces had same-sign Z normals. Now checks if normal points in same
         direction as V-vector (up slope), which indicates inverted orientation.
- 4.3.2: TNP FIX: Pass actual objects instead of names to avoid doc.getObject() lookups.
         Function signature changed: generate_shingles(face, base_object, params)
         No more string-based object lookups - everything uses PropertyLink references.
- 4.3.1: FEATURE: Compound shingle skin with base roof object.
         Creates Part::Compound containing both base roof and shingle skin.
         This keeps shingles and roof together - delete/hide/move as unit.
         Fixed smart_trim_demo to handle edge selections (uses largest face).
- 4.3.0: FEATURE: Smart trim angle computation for valleys and hips.
         Added compute_face_intersection_angle() and compute_edge_intersection_angle()
         for automatic detection of roof intersection angles.
         BUG FIX: Use PropertyLink instead of PropertyString for base object reference
         to avoid TNP issues when base object is renamed.
- 4.2.3: BUG FIX: Face extent calculation now projects all vertices onto U/V directions.
         Previously used edge lengths from origin vertex, which on Boolean-cut faces
         (hexagons, heptagons) only measured to adjacent vertices, not full face extent.
         Result: Reported dimensions like 58.9x63.2mm for a 9702mm² face, causing severe
         under-coverage. Now calculates actual face bounds along U/V axes.
- 4.2.2: BUG FIX: Origin vertex selection now prefers corner vertices (2 edges meeting).
         Previously used lowest Z vertex, which on Boolean-cut faces could be along
         the cut edge rather than at a proper corner. This caused shingles to start
         in the middle of faces (e.g., at dormer valleys) leaving gaps at actual edges.
- 4.2.1: BUG FIX: Face orientation detection now uses Z-component instead of edge length.
         Previously assumed longer edge = width, but this failed on faces where the
         vertical dimension was longer than horizontal (e.g., narrow peaked roofs).
         Now correctly identifies up-slope direction by Z-component change.
- 4.2.0: Feature: Support linked spreadsheets for multi-file projects.
         Updated default parameters to newer HO scale values (3.5 × 2.0 mm).
- 4.1.0: Performance: Use Part::Compound instead of fusing all shingles.
         Eliminates 2-minute+ batch fusion step. Fuse on-demand if Boolean
         operations needed. 55 tests passing.
- 4.0.0: MAJOR REFACTOR - Extract geometry to shingle_geometry.py
         Face-based selection (match clapboard v5.2.0 pattern)
         Add comprehensive parameter and face validation
         Separate geometry logic from FreeCAD I/O
- 3.6.3: Previous version with all geometry inline

Requires: shingle_geometry.py in same directory as macro
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
from FreeCAD import Vector
import math
import sys
import os
import gc  # For garbage collection monitoring

# Import geometry library
try:
    import sys
    import os
    # Add _lib directory to path so we can import geometry modules
    macro_dir = os.path.dirname(__file__)
    lib_dir = os.path.join(macro_dir, "_lib")
    if lib_dir not in sys.path:
        sys.path.insert(0, lib_dir)
    
    from shingle_geometry import (
        validate_parameters,
        validate_stagger_pattern,
        calculate_layout,
        calculate_stagger_offset,
        validate_face_for_shingling,
        calculate_face_bounds,
        detect_face_orientation,
        get_orientation_description,
        calculate_shingle_position,
        validate_collar_margin,
        # v5.0.0: Bounding-box based orientation
        find_eave_and_ridge_vertices,
        calculate_upslope_direction,
        calculate_across_roof_direction,
        get_roof_coordinate_system,
        # v5.0.0: Smart trim functions
        find_coincident_edges,
        classify_roof_intersection,
        calculate_dihedral_angle,
        analyze_roof_intersection,
    )
except ImportError as e:
    print(f"ERROR: Could not import shingle_geometry.py: {e}")
    print("Make sure shingle_geometry.py is in the _lib subdirectory of your Macro folder")
    sys.exit(1)

VERSION = "5.0.0"
GENERATOR_NAME = "shingle_generator"


def find_spreadsheet(doc, preferred_names):
    """
    Find spreadsheet by checking both object name and label.
    Follows Links to find the actual Spreadsheet::Sheet object.
    """
    for ss_name in preferred_names:
        # Try by object name first
        obj = doc.getObject(ss_name)
        if obj:
            # If it's a Link, follow it to the target
            if obj.TypeId == 'App::Link':
                target = obj.LinkedObject
                if target and target.TypeId == 'Spreadsheet::Sheet':
                    print(f"Found spreadsheet via link: '{ss_name}' → '{target.Name}'")
                    return target
            # If it's already a spreadsheet, use it
            elif obj.TypeId == 'Spreadsheet::Sheet':
                print(f"Found spreadsheet by name: '{ss_name}'")
                return obj
        
        # Try by label
        for obj in doc.Objects:
            if obj.Label == ss_name:
                # If it's a Link, follow it
                if obj.TypeId == 'App::Link':
                    target = obj.LinkedObject
                    if target and target.TypeId == 'Spreadsheet::Sheet':
                        print(f"Found spreadsheet via link: '{ss_name}' → '{target.Name}' (object name: '{obj.Name}')")
                        return target
                # If it's already a spreadsheet, use it
                elif obj.TypeId == 'Spreadsheet::Sheet':
                    print(f"Found spreadsheet by label: '{ss_name}' (object name: '{obj.Name}')")
                    return obj
    
    return None


def get_params_from_spreadsheet(doc):
    """
    Try to read shingle parameters from spreadsheet.
    """
    preferred_names = ["params", "ShingleParameters", "BuildingParameters", "Spreadsheet"]
    
    ss = find_spreadsheet(doc, preferred_names)
    if ss is None:
        return None
    
    params = {}
    param_map = {
        'shingleWidth': ['shingleWidth', 'ShingleWidth', 'shingle_width'],
        'shingleHeight': ['shingleHeight', 'ShingleHeight', 'shingle_height'],
        'materialThickness': ['materialThickness', 'MaterialThickness', 'thickness'],
        'shingleExposure': ['shingleExposure', 'ShingleExposure', 'shingle_exposure', 'exposure'],
        'shingleStaggerPattern': ['shingleStaggerPattern', 'StaggerPattern', 'stagger_pattern'],
        'shingleWedgeThickness': ['shingleWedgeThickness', 'WedgeThickness', 'wedge_thickness'],
    }
    
    for param_key, possible_names in param_map.items():
        for name in possible_names:
            try:
                val = ss.get(name)
                if val is not None:
                    # Try to convert to float, except for string parameter
                    if param_key == 'shingleStaggerPattern':
                        # Strip quotes and whitespace from string values
                        params[param_key] = str(val).strip().strip("'\"").lower()
                    else:
                        params[param_key] = float(val)
                    break
            except:
                continue
    
    return params if params else None


def get_face_coordinate_system(face):
    """
    Extract coordinate system from a planar face using bounding-box method.

    v5.0.0: Now uses vertex Z coordinates to determine orientation instead of
    relying on face normals or edge directions. This approach is geometrically
    unambiguous - the eave is always the lowest Z, ridge is highest Z, and
    V-direction points from eave to ridge.

    Returns:
        tuple: (origin, u_vec, v_vec, normal, u_length, v_length)
            origin: Corner point of face (lowest Z corner vertex)
            u_vec: Unit vector along width (U direction, across roof)
            v_vec: Unit vector along height (V direction, up slope)
            normal: Unit vector perpendicular to face (outward)
            u_length: Length along U direction
            v_length: Length along V direction
    """

    # Convert FreeCAD vertices to tuples for geometry library
    vertices_tuples = [(v.Point.x, v.Point.y, v.Point.z) for v in face.Vertexes]

    # Get face normal from FreeCAD
    fc_normal = face.normalAt(0.5, 0.5).normalize()
    normal_tuple = (fc_normal.x, fc_normal.y, fc_normal.z)

    # Use bounding-box based coordinate system (v5.0.0)
    coord_sys = get_roof_coordinate_system(vertices_tuples, normal_tuple)

    # Convert back to FreeCAD vectors
    origin_tuple = coord_sys['origin']
    origin = App.Vector(origin_tuple[0], origin_tuple[1], origin_tuple[2])

    u_tuple = coord_sys['u_vec']
    u_vec = App.Vector(u_tuple[0], u_tuple[1], u_tuple[2])

    v_tuple = coord_sys['v_vec']
    v_vec = App.Vector(v_tuple[0], v_tuple[1], v_tuple[2])

    normal_tuple = coord_sys['normal']
    normal = App.Vector(normal_tuple[0], normal_tuple[1], normal_tuple[2])

    # Find best origin: prefer corner vertex (2 edges meeting) at lowest Z
    # This is important for shingle placement to start at a proper corner
    vertices = face.Vertexes
    edges = face.Edges

    # Count edges meeting at each vertex
    vertex_edge_count = {}
    for vertex in vertices:
        count = 0
        for edge in edges:
            v1 = edge.Vertexes[0].Point
            v2 = edge.Vertexes[1].Point
            if v1.distanceToPoint(vertex.Point) < 0.001 or v2.distanceToPoint(vertex.Point) < 0.001:
                count += 1
        vertex_edge_count[vertex] = count

    # Find corner vertices (exactly 2 edges meeting) at the eave level
    eave_z = coord_sys['eave_ridge_info']['eave_z']
    z_tolerance = 0.1

    corner_vertices_at_eave = [
        v for v in vertices
        if vertex_edge_count[v] == 2 and abs(v.Point.z - eave_z) <= z_tolerance
    ]

    if corner_vertices_at_eave:
        # Use the corner vertex at eave level
        origin = corner_vertices_at_eave[0].Point
    # else: keep the origin from coord_sys

    # Calculate face extents by projecting all vertices onto U and V directions
    u_projections = []
    v_projections = []

    for vertex in face.Vertexes:
        vec_to_vertex = vertex.Point.sub(origin)
        u_proj = vec_to_vertex.dot(u_vec)
        v_proj = vec_to_vertex.dot(v_vec)
        u_projections.append(u_proj)
        v_projections.append(v_proj)

    u_length = max(u_projections) - min(u_projections)
    v_length = max(v_projections) - min(v_projections)

    return origin, u_vec, v_vec, normal, u_length, v_length


def scale_vector(vec, scale):
    """Properly scale a vector by component multiplication"""
    return App.Vector(vec.x * scale, vec.y * scale, vec.z * scale)


def compute_edge_intersection_angle(edge1, edge2):
    """
    Compute the dihedral angle between two roof edges/faces.
    
    Args:
        edge1: First edge (from a roof face)
        edge2: Second edge (from another roof face)
    
    Returns:
        Dictionary with:
            - angle_degrees: The dihedral angle in degrees
            - angle_radians: The dihedral angle in radians
            - bisector_direction: Unit vector along the angle bisector
            - edge1_normal: Normal of first face
            - edge2_normal: Normal of second face
    """
    # Get the faces adjacent to each edge
    # For now, we'll compute based on edge tangents and assume roof planes
    
    # Get edge tangent vectors
    tangent1 = edge1.Curve.Direction if hasattr(edge1.Curve, 'Direction') else edge1.tangentAt(edge1.FirstParameter)
    tangent2 = edge2.Curve.Direction if hasattr(edge2.Curve, 'Direction') else edge2.tangentAt(edge2.FirstParameter)
    
    # Normalize
    tangent1.normalize()
    tangent2.normalize()
    
    # Calculate angle between tangents
    dot_product = tangent1.dot(tangent2)
    # Clamp to [-1, 1] to handle floating point errors
    dot_product = max(-1.0, min(1.0, dot_product))
    
    angle_rad = math.acos(dot_product)
    angle_deg = math.degrees(angle_rad)
    
    # Calculate bisector direction (for valley/hip trim orientation)
    bisector = (tangent1 + tangent2).normalize()
    
    return {
        'angle_degrees': angle_deg,
        'angle_radians': angle_rad,
        'bisector_direction': bisector,
        'tangent1': tangent1,
        'tangent2': tangent2,
    }


def compute_face_intersection_angle(face1, face2):
    """
    Compute the dihedral angle between two roof faces at their intersection.
    This is the proper way to get valley/hip angles.

    v5.0.0: Now uses Z-based classification to reliably distinguish valleys from
    ridges. The key insight: at a shared edge, if non-shared vertices of both faces
    are BELOW the edge, it's a ridge/hip. If ABOVE, it's a valley.

    Args:
        face1: First roof face (FreeCAD face object)
        face2: Second roof face (FreeCAD face object)

    Returns:
        Dictionary with:
            - dihedral_angle_degrees: The dihedral angle between faces
            - dihedral_angle_radians: The dihedral angle in radians
            - intersection_edge: The edge where faces meet (if they intersect)
            - normal1: Normal vector of face1
            - normal2: Normal vector of face2
            - is_valley: True if this is a valley
            - is_hip: True if this is a hip/ridge
            - classification_confidence: 'high', 'medium', or 'low'
            - trim_recommendation: Human-readable trim advice
    """
    # Get face normals
    uv1 = face1.ParameterRange
    u1_mid = (uv1[0] + uv1[1]) / 2
    v1_mid = (uv1[2] + uv1[3]) / 2
    normal1 = face1.normalAt(u1_mid, v1_mid)

    uv2 = face2.ParameterRange
    u2_mid = (uv2[0] + uv2[1]) / 2
    v2_mid = (uv2[2] + uv2[3]) / 2
    normal2 = face2.normalAt(u2_mid, v2_mid)

    # Convert to tuples for geometry library
    face1_vertices = [(v.Point.x, v.Point.y, v.Point.z) for v in face1.Vertexes]
    face2_vertices = [(v.Point.x, v.Point.y, v.Point.z) for v in face2.Vertexes]

    normal1_tuple = (normal1.x, normal1.y, normal1.z)
    normal2_tuple = (normal2.x, normal2.y, normal2.z)

    # Convert edges to tuples
    face1_edges = [
        ((e.Vertexes[0].Point.x, e.Vertexes[0].Point.y, e.Vertexes[0].Point.z),
         (e.Vertexes[1].Point.x, e.Vertexes[1].Point.y, e.Vertexes[1].Point.z))
        for e in face1.Edges
    ]
    face2_edges = [
        ((e.Vertexes[0].Point.x, e.Vertexes[0].Point.y, e.Vertexes[0].Point.z),
         (e.Vertexes[1].Point.x, e.Vertexes[1].Point.y, e.Vertexes[1].Point.z))
        for e in face2.Edges
    ]

    # Use geometry library for Z-based analysis (v5.0.0)
    analysis = analyze_roof_intersection(
        face1_vertices, normal1_tuple, face1_edges,
        face2_vertices, normal2_tuple, face2_edges,
        tolerance=0.5
    )

    # Calculate dihedral angle (still useful even if classification is from Z-based method)
    dot_product = normal1.dot(normal2)
    dot_product = max(-1.0, min(1.0, dot_product))

    angle_rad = math.acos(dot_product)
    angle_deg = math.degrees(angle_rad)

    # Determine classification from Z-based analysis
    if analysis['has_shared_edge']:
        classification = analysis['classification']
        is_valley = classification == 'valley'
        is_hip = classification == 'ridge'
        confidence = analysis['classification_details'].get('confidence', 'medium')
        trim_recommendation = analysis['trim_recommendation']
    else:
        # No shared edge found - fall back to normal-based heuristic
        if angle_deg < 90:
            is_hip = True
            is_valley = False
        else:
            is_valley = True
            is_hip = False
        confidence = 'low'
        trim_recommendation = f"No shared edge found. Dihedral angle: {angle_deg:.1f}°"

    # Calculate trim angle
    trim_angle = angle_deg / 2

    # Try to find FreeCAD intersection edge for reference
    intersection_edge = None
    try:
        edges1 = set(face1.Edges)
        edges2 = set(face2.Edges)
        common_edges = edges1.intersection(edges2)
        if common_edges:
            intersection_edge = list(common_edges)[0]
    except:
        pass

    return {
        'dihedral_angle_degrees': angle_deg,
        'dihedral_angle_radians': angle_rad,
        'normal1': normal1,
        'normal2': normal2,
        'intersection_edge': intersection_edge,
        'is_valley': is_valley,
        'is_hip': is_hip,
        'trim_angle_degrees': trim_angle,
        'classification_confidence': confidence,
        'trim_recommendation': trim_recommendation,
        'shared_edges': analysis.get('shared_edges', []),
    }


def generate_shingles(face, base_object, params):
    """
    Generate shingles on a face.
    
    Args:
        face: The face to cover with shingles
        base_object: The actual base object (not its name!) - for PropertyLink reference
        params: Dictionary with parameters:
            - shingleWidth: Width of each shingle (mm)
            - shingleHeight: Height of each shingle (mm)
            - materialThickness: Thickness of material (mm)
            - shingleExposure: Exposed portion per course (mm)
            - shingleStaggerPattern: "half", "third", or "none"
            - shingleWedgeThickness: Base thickness of triangular wedges (mm)
    
    Returns:
        Part::Feature object containing the shingle compound
    """
    
    doc = App.ActiveDocument
    
    # Check if base_object is already a ShingledRoof compound
    # If so, extract the original base object to avoid recursive compounding
    original_base_obj = base_object
    
    if base_object.TypeId == 'Part::Compound':
        # Check if it's a ShingledRoof compound (has our metadata)
        if hasattr(base_object, 'BaseObject') and base_object.BaseObject:
            print(f"⚠️  Detected existing ShingledRoof compound: {base_object.Name}")
            print(f"   Using original base object: {base_object.BaseObject.Name}")
            original_base_obj = base_object.BaseObject
        elif 'ShingledRoof_' in base_object.Name:
            # It's a ShingledRoof but no BaseObject property - try to extract by name (fallback)
            original_base_name = base_object.Name.replace('ShingledRoof_', '', 1)
            print(f"⚠️  Detected ShingledRoof compound (no BaseObject property)")
            print(f"   Attempting to find: {original_base_name}")
            fallback_obj = doc.getObject(original_base_name)
            if fallback_obj:
                original_base_obj = fallback_obj
            else:
                print(f"   ⚠️  Could not find base object by name, using compound")
    
    base_obj = original_base_obj
    
    # Extract parameters
    shingle_width = params.get('shingleWidth', 10.0)
    shingle_height = params.get('shingleHeight', 20.0)
    shingle_thickness = params.get('materialThickness', 0.5)
    exposure = params.get('shingleExposure', 15.0)
    stagger_pattern = params.get('shingleStaggerPattern', 'half')
    wedge_thickness = params.get('shingleWedgeThickness', shingle_thickness)
    
    print(f"\n{'='*60}")
    print(f"Shingle Generator v{VERSION}")
    print(f"{'='*60}")
    print(f"Source: {base_obj.Name}")
    print(f"Shingle: {shingle_width} x {shingle_height} x {shingle_thickness} mm")
    print(f"Wedge base: {wedge_thickness} mm")
    print(f"Exposure: {exposure} mm")
    print(f"Stagger: {stagger_pattern}\n")
    
    # Get face coordinate system using bounding-box method (v5.0.0)
    # This reliably determines eave-to-ridge direction from vertex Z coordinates
    origin, u_vec, v_vec, normal, u_length, v_length = get_face_coordinate_system(face)

    print(f"  Orientation (v5.0.0 bounding-box method):")
    print(f"  Normal: ({normal.x:.3f}, {normal.y:.3f}, {normal.z:.3f})")
    print(f"  V-vec (up slope): ({v_vec.x:.3f}, {v_vec.y:.3f}, {v_vec.z:.3f})")
    print(f"  U-vec (across): ({u_vec.x:.3f}, {u_vec.y:.3f}, {u_vec.z:.3f})\n")
    
    print(f"Face dimensions: {u_length:.1f} x {v_length:.1f} mm")
    
    # Use geometry library to calculate layout
    layout = calculate_layout(u_length, v_length, shingle_width, exposure, stagger_pattern)
    
    num_courses = layout['num_courses']
    shingles_per_course = layout['shingles_per_course']
    max_stagger = layout['max_stagger']
    
    print(f"Courses: {num_courses}")
    print(f"Shingles per course: {shingles_per_course}")
    print(f"Total (before trimming): {num_courses * shingles_per_course}\n")
    
    # Generate shingles with solid trapezoid geometry
    shingle_shapes = []
    
    # Create clipping volume based on face geometry
    # Extrude the face to create a 3D clipping volume that respects face orientation
    clip_margin = shingle_thickness * 2  # Allow small overhang for material thickness
    
    try:
        # Extrude face inward and outward to create clipping volume
        extrusion_depth = 100.0  # Large enough to capture all shingles
        clip_volume_pos = face.extrude(normal.multiply(extrusion_depth))
        clip_volume_neg = face.extrude(normal.multiply(-extrusion_depth))
        clip_volume = clip_volume_pos.fuse(clip_volume_neg)
        
        print(f"✓ Face-based clipping volume created\n")
    except Exception as e:
        print(f"Warning: Could not create face clipping volume: {e}")
        print(f"Proceeding without per-shingle clipping\n")
        clip_volume = None
    
    for row in range(num_courses):
        # Calculate stagger offset for this row (using geometry library)
        stagger = calculate_stagger_offset(row, stagger_pattern, shingle_width)
        
        for col in range(shingles_per_course):
            # Start before origin to ensure full coverage
            u = col * shingle_width + stagger - max_stagger
            v = row * exposure - exposure  # Start one course below origin
            
            # Calculate base position (top edge of shingle on roof surface)
            u_scaled = scale_vector(u_vec, u)
            v_scaled = scale_vector(v_vec, v)
            top_position = origin + u_scaled + v_scaled
            
            # Build rotation matrix from target coordinate system
            # Shingle local coords: X=width, Y=height(down slope), Z=thickness(outward)
            # Target coords: U=across, V=up slope, Normal=outward
            # So: local X -> U, local Y -> V, local Z -> Normal
            rotation_matrix = App.Matrix(
                u_vec.x, v_vec.x, normal.x, 0,
                u_vec.y, v_vec.y, normal.y, 0,
                u_vec.z, v_vec.z, normal.z, 0,
                0, 0, 0, 1
            )
            final_rotation = App.Rotation(rotation_matrix)

            # Create shingle geometry based on row
            if row == 0:
                # Row 0: Rectangular box with exposed height only
                shingle_shape = Part.makeBox(shingle_width, exposure, shingle_thickness)
                shingle_shape.Placement = App.Placement(top_position, final_rotation)

            else:
                # Row 1+: Triangular wedge cross-section
                # Top edge: thin (wedge_thickness) against roof
                # Bottom edge: tapers to a point
                # Height: full shingle_height

                p1 = App.Vector(0, 0, 0)                      # Top back (against roof, uphill)
                p2 = App.Vector(0, 0, wedge_thickness)        # Top front (visible surface, uphill)
                p3 = App.Vector(0, shingle_height, 0)         # Bottom point (tapers to roof surface)

                # Create edges connecting the points
                l1 = Part.LineSegment(p1, p2)
                l2 = Part.LineSegment(p2, p3)
                l3 = Part.LineSegment(p3, p1)

                # Make wire from edges
                profile_wire = Part.Wire([l1.toShape(), l2.toShape(), l3.toShape()])

                # Create face from wire
                profile_face = Part.Face(profile_wire)

                # Extrude along shingle width
                extrude_vector = App.Vector(shingle_width, 0, 0)
                shingle_shape = profile_face.extrude(extrude_vector)

                shingle_shape.Placement = App.Placement(top_position, final_rotation)
            
            # Clip shingle to face boundary if clipping volume exists
            if clip_volume is not None:
                try:
                    clipped_shingle = shingle_shape.common(clip_volume)
                    # Only keep shingles with real geometry
                    if clipped_shingle.Volume > 0.001:
                        shingle_shapes.append(clipped_shingle)
                    # else: shingle was completely outside bounds, skip it
                except Exception as e:
                    # If clipping fails, keep original (graceful degradation)
                    if shingle_shape.Volume > 0.001:
                        shingle_shapes.append(shingle_shape)
            else:
                # No clipping volume, use original
                shingle_shapes.append(shingle_shape)
    
    print(f"Generated {len(shingle_shapes)} shingles\n")
    
    if len(shingle_shapes) == 0:
        raise ValueError("No shingles generated!")
    
    # Create a compound from all shingles (no Boolean operations)
    # This is fast and clean. If Boolean operations are needed later,
    # fuse the compound at that point (lazy evaluation).
    print("Creating compound from shingles...")
    compound_shape = Part.Compound(shingle_shapes)
    
    print(f"✓ Created compound with {len(shingle_shapes)} shingles\n")
    
    # Validate the compound
    if compound_shape.isNull():
        raise ValueError(f"Compound is invalid!")
    
    print(f"  Compound volume: {compound_shape.Volume:.1f} mm³")
    
    # Per-shingle clipping already removed overhang geometry
    # No additional trimming needed - shingles are already clipped to face bounds
    trimmed_compound = compound_shape
    print("✓ Shingles clipped to face boundaries during generation\n")
    
    # Create shingle skin as Part::Feature
    # Create shingle skin as Part::Feature
    shingle_skin_name = f"ShingleSkin_{base_obj.Name}"
    shingle_skin = doc.addObject("Part::Feature", shingle_skin_name)
    shingle_skin.Shape = trimmed_compound
    
    # Add metadata to shingle skin
    shingle_skin.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator name")
    shingle_skin.GeneratorName = GENERATOR_NAME
    
    shingle_skin.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
    shingle_skin.GeneratorVersion = VERSION
    
    print(f"✓ Created shingle skin: {shingle_skin_name}")
    
    # Create compound with the base object and shingle skin
    print(f"Creating compound of shingle skin + base object...")
    
    # Create a Part::Compound to hold both the base object and shingle skin
    result_name = f"ShingledRoof_{base_obj.Name}"
    result_obj = doc.addObject("Part::Compound", result_name)
    result_obj.Links = [base_obj, shingle_skin]
    
    # Add metadata to compound
    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator name")
    result_obj.GeneratorName = GENERATOR_NAME
    
    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
    result_obj.GeneratorVersion = VERSION
    
    result_obj.addProperty("App::PropertyLink", "BaseObject", "Metadata", "Base roof object")
    result_obj.BaseObject = base_obj
    
    result_obj.addProperty("App::PropertyLink", "ShingleSkin", "Metadata", "Shingle skin object")
    result_obj.ShingleSkin = shingle_skin
    
    print(f"✓ Created compound: {result_name}")
    print(f"  └─ Contains: {base_obj.Name} + {shingle_skin.Name}")
    
    doc.recompute()
    
    print(f"✓ Created: {result_name}")
    return result_obj


# ============================================================================
# Main execution
# ============================================================================

if __name__ == "__main__":
    
    doc = App.ActiveDocument
    
    if not doc:
        print("ERROR: No active document")
    else:
        print(f"\n{'='*60}")
        print(f"Shingle Generator v{VERSION}")
        print(f"{'='*60}\n")
        
        # Try to get parameters from spreadsheet
        params_sheet = doc.getObject("Spreadsheet")
        
        if params_sheet:
            try:
                params = get_params_from_spreadsheet(doc)
                if params:
                    print("Loaded parameters from spreadsheet:")
                    for key, val in params.items():
                        print(f"  {key}: {val}")
                    print()
                else:
                    print("Warning: Could not load parameters from spreadsheet, using defaults\n")
                    params = {
                        'shingleWidth': 3.5,
                        'shingleHeight': 2.0,
                        'materialThickness': 0.25,
                        'shingleExposure': 1.5,
                        'shingleStaggerPattern': 'half'
                    }
            except Exception as e:
                print(f"Warning: {e}")
                print("Using default parameters\n")
                params = {
                    'shingleWidth': 3.5,
                    'shingleHeight': 2.0,
                    'materialThickness': 0.25,
                    'shingleExposure': 1.5,
                    'shingleStaggerPattern': 'half'
                }
        else:
            print("No spreadsheet found, using default parameters:")
            params = {
                'shingleWidth': 3.5,
                'shingleHeight': 2.0,
                'materialThickness': 0.25,
                'shingleExposure': 1.5,
                'shingleStaggerPattern': 'half'
            }
            for key, val in params.items():
                print(f"  {key}: {val}")
            print()
        
        # Validate parameters early
        is_valid, errors = validate_parameters(
            params['shingleWidth'],
            params['shingleHeight'],
            params['materialThickness'],
            params['shingleExposure']
        )
        
        if not is_valid:
            print("ERROR: Invalid parameters:")
            for error in errors:
                print(f"  - {error}")
            print()
        else:
            is_valid, msg = validate_stagger_pattern(params['shingleStaggerPattern'])
            if not is_valid:
                print(f"ERROR: {msg}\n")
            else:
                # Get selected faces
                selection = Gui.Selection.getSelectionEx()
                
                if not selection:
                    print("ERROR: No faces selected!")
                    print("\nUsage:")
                    print("1. Select one or more roof faces (Ctrl+click in 3D view)")
                    print("2. Run this macro")
                    print()
                elif not selection[0].HasSubObjects:
                    print("ERROR: Please select faces, not just objects")
                    print("\nUsage:")
                    print("1. Select one or more faces by Ctrl+clicking on roof surfaces")
                    print("2. Run this macro")
                    print()
                else:
                    # Process selected faces
                    success_count = 0
                    fail_count = 0
                    
                    for sel in selection:
                        obj_name = sel.Object.Label
                        base_obj = sel.Object  # Pass the actual object, not its name!
                        
                        for sub_element in sel.SubElementNames:
                            if not sub_element.startswith("Face"):
                                print(f"ERROR: '{sub_element}' is not a face, skipping\n")
                                continue
                            
                            try:
                                # Get the actual face object
                                face_index = int(sub_element[4:]) - 1  # Face6 -> index 5
                                face = sel.Object.Shape.Faces[face_index]
                                
                                print(f"\n{'='*60}")
                                print(f"Processing: {obj_name} / {sub_element}")
                                print(f"{'='*60}")
                                
                                # Generate shingles for this face - pass actual object, not name!
                                result = generate_shingles(face, base_obj, params)
                                
                                print(f"\n✓ SUCCESS: Generated shingles for {obj_name}/{sub_element}\n")
                                success_count += 1
                                
                            except Exception as e:
                                print(f"\n✗ FAILED: {e}\n")
                                fail_count += 1
                                import traceback
                                traceback.print_exc()
                    
                    print(f"\n{'='*60}")
                    print(f"SUMMARY: {success_count} succeeded, {fail_count} failed")
                    print(f"{'='*60}\n")
