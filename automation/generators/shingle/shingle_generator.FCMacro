"""
Parametric Shingle Generator for FreeCAD v4.3.2
Generates realistic shingles on roof surfaces from selected faces

Author: Brian (with Claude assistance)
Usage: Select one or more roof faces, run as macro in FreeCAD

Version History:
- 4.3.2: TNP FIX: Pass actual objects instead of names to avoid doc.getObject() lookups.
         Function signature changed: generate_shingles(face, base_object, params)
         No more string-based object lookups - everything uses PropertyLink references.
- 4.3.1: FEATURE: Compound shingle skin with base roof object.
         Creates Part::Compound containing both base roof and shingle skin.
         This keeps shingles and roof together - delete/hide/move as unit.
         Fixed smart_trim_demo to handle edge selections (uses largest face).
- 4.3.0: FEATURE: Smart trim angle computation for valleys and hips.
         Added compute_face_intersection_angle() and compute_edge_intersection_angle()
         for automatic detection of roof intersection angles.
         BUG FIX: Use PropertyLink instead of PropertyString for base object reference
         to avoid TNP issues when base object is renamed.
- 4.2.3: BUG FIX: Face extent calculation now projects all vertices onto U/V directions.
         Previously used edge lengths from origin vertex, which on Boolean-cut faces
         (hexagons, heptagons) only measured to adjacent vertices, not full face extent.
         Result: Reported dimensions like 58.9x63.2mm for a 9702mm² face, causing severe
         under-coverage. Now calculates actual face bounds along U/V axes.
- 4.2.2: BUG FIX: Origin vertex selection now prefers corner vertices (2 edges meeting).
         Previously used lowest Z vertex, which on Boolean-cut faces could be along
         the cut edge rather than at a proper corner. This caused shingles to start
         in the middle of faces (e.g., at dormer valleys) leaving gaps at actual edges.
- 4.2.1: BUG FIX: Face orientation detection now uses Z-component instead of edge length.
         Previously assumed longer edge = width, but this failed on faces where the
         vertical dimension was longer than horizontal (e.g., narrow peaked roofs).
         Now correctly identifies up-slope direction by Z-component change.
- 4.2.0: Feature: Support linked spreadsheets for multi-file projects.
         Updated default parameters to newer HO scale values (3.5 × 2.0 mm).
- 4.1.0: Performance: Use Part::Compound instead of fusing all shingles.
         Eliminates 2-minute+ batch fusion step. Fuse on-demand if Boolean
         operations needed. 55 tests passing.
- 4.0.0: MAJOR REFACTOR - Extract geometry to shingle_geometry.py
         Face-based selection (match clapboard v5.2.0 pattern)
         Add comprehensive parameter and face validation
         Separate geometry logic from FreeCAD I/O
- 3.6.3: Previous version with all geometry inline

Requires: shingle_geometry.py in same directory as macro
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
from FreeCAD import Vector
import math
import sys
import os
import gc  # For garbage collection monitoring

# Import geometry library
try:
    import sys
    import os
    # Add _lib directory to path so we can import geometry modules
    macro_dir = os.path.dirname(__file__)
    lib_dir = os.path.join(macro_dir, "_lib")
    if lib_dir not in sys.path:
        sys.path.insert(0, lib_dir)
    
    from shingle_geometry import (
        validate_parameters,
        validate_stagger_pattern,
        calculate_layout,
        calculate_stagger_offset,
        validate_face_for_shingling,
        calculate_face_bounds,
        detect_face_orientation,
        get_orientation_description,
        calculate_shingle_position,
        validate_collar_margin,
    )
except ImportError as e:
    print(f"ERROR: Could not import shingle_geometry.py: {e}")
    print("Make sure shingle_geometry.py is in the _lib subdirectory of your Macro folder")
    sys.exit(1)

VERSION = "4.3.2"
GENERATOR_NAME = "shingle_generator"


def find_spreadsheet(doc, preferred_names):
    """
    Find spreadsheet by checking both object name and label.
    Follows Links to find the actual Spreadsheet::Sheet object.
    """
    for ss_name in preferred_names:
        # Try by object name first
        obj = doc.getObject(ss_name)
        if obj:
            # If it's a Link, follow it to the target
            if obj.TypeId == 'App::Link':
                target = obj.LinkedObject
                if target and target.TypeId == 'Spreadsheet::Sheet':
                    print(f"Found spreadsheet via link: '{ss_name}' → '{target.Name}'")
                    return target
            # If it's already a spreadsheet, use it
            elif obj.TypeId == 'Spreadsheet::Sheet':
                print(f"Found spreadsheet by name: '{ss_name}'")
                return obj
        
        # Try by label
        for obj in doc.Objects:
            if obj.Label == ss_name:
                # If it's a Link, follow it
                if obj.TypeId == 'App::Link':
                    target = obj.LinkedObject
                    if target and target.TypeId == 'Spreadsheet::Sheet':
                        print(f"Found spreadsheet via link: '{ss_name}' → '{target.Name}' (object name: '{obj.Name}')")
                        return target
                # If it's already a spreadsheet, use it
                elif obj.TypeId == 'Spreadsheet::Sheet':
                    print(f"Found spreadsheet by label: '{ss_name}' (object name: '{obj.Name}')")
                    return obj
    
    return None


def get_params_from_spreadsheet(doc):
    """
    Try to read shingle parameters from spreadsheet.
    """
    preferred_names = ["params", "ShingleParameters", "BuildingParameters", "Spreadsheet"]
    
    ss = find_spreadsheet(doc, preferred_names)
    if ss is None:
        return None
    
    params = {}
    param_map = {
        'shingleWidth': ['shingleWidth', 'ShingleWidth', 'shingle_width'],
        'shingleHeight': ['shingleHeight', 'ShingleHeight', 'shingle_height'],
        'materialThickness': ['materialThickness', 'MaterialThickness', 'thickness'],
        'shingleExposure': ['shingleExposure', 'ShingleExposure', 'shingle_exposure', 'exposure'],
        'shingleStaggerPattern': ['shingleStaggerPattern', 'StaggerPattern', 'stagger_pattern'],
        'shingleWedgeThickness': ['shingleWedgeThickness', 'WedgeThickness', 'wedge_thickness'],
    }
    
    for param_key, possible_names in param_map.items():
        for name in possible_names:
            try:
                val = ss.get(name)
                if val is not None:
                    # Try to convert to float, except for string parameter
                    if param_key == 'shingleStaggerPattern':
                        # Strip quotes and whitespace from string values
                        params[param_key] = str(val).strip().strip("'\"").lower()
                    else:
                        params[param_key] = float(val)
                    break
            except:
                continue
    
    return params if params else None


def get_face_coordinate_system(face):
    """
    Extract coordinate system from a planar face.
    
    Returns:
        tuple: (origin, u_vec, v_vec, normal, u_length, v_length)
            origin: Corner point of face (lowest Z vertex)
            u_vec: Unit vector along width (U direction)
            v_vec: Unit vector along height (V direction)  
            normal: Unit vector perpendicular to face
            u_length: Length along U direction
            v_length: Length along V direction
    """
    
    # Get vertices - find a CORNER vertex at the lowest Z to start at the eave
    # A corner vertex is one where exactly 2 edges meet (not 3+ which indicates a cut/intersection)
    vertices = face.Vertexes
    edges = face.Edges
    
    # Count edges meeting at each vertex
    vertex_edge_count = {}
    for vertex in vertices:
        count = 0
        for edge in edges:
            v1 = edge.Vertexes[0].Point
            v2 = edge.Vertexes[1].Point
            if v1.distanceToPoint(vertex.Point) < 0.001 or v2.distanceToPoint(vertex.Point) < 0.001:
                count += 1
        vertex_edge_count[vertex] = count
    
    # Find corner vertices (exactly 2 edges meeting)
    corner_vertices = [v for v in vertices if vertex_edge_count[v] == 2]
    
    # If we have corner vertices, use the lowest one
    # Otherwise fall back to lowest vertex overall
    if corner_vertices:
        sorted_corners = sorted(corner_vertices, key=lambda v: v.Point.z)
        origin = sorted_corners[0].Point
    else:
        sorted_by_z = sorted(vertices, key=lambda v: v.Point.z)
        origin = sorted_by_z[0].Point
    
    # Find edges that share the origin vertex
    origin_edges = []
    for edge in edges:
        v1 = edge.Vertexes[0].Point
        v2 = edge.Vertexes[1].Point
        if v1.distanceToPoint(origin) < 0.001 or v2.distanceToPoint(origin) < 0.001:
            origin_edges.append(edge)
    
    if len(origin_edges) < 2:
        raise ValueError(f"Need at least 2 edges from origin, found {len(origin_edges)}")
    
    # Determine which edge goes up the slope vs across:
    # - V (height) should go up the slope (larger Z component)
    # - U (width) should go across the roof (smaller Z component)
    
    # Get direction vectors for both edges from origin
    edge_dirs = []
    for edge in origin_edges[:2]:  # Only need first 2
        if edge.Vertexes[0].Point.distanceToPoint(origin) < 0.001:
            direction = edge.Vertexes[1].Point.sub(edge.Vertexes[0].Point)
        else:
            direction = edge.Vertexes[0].Point.sub(edge.Vertexes[1].Point)
        edge_dirs.append((edge, abs(direction.z)))
    
    # Sort by Z component - edge with larger Z change goes up slope (V)
    sorted_by_z = sorted(edge_dirs, key=lambda x: x[1])
    u_edge = sorted_by_z[0][0]  # Smaller Z = across roof (U/width)
    v_edge = sorted_by_z[1][0]  # Larger Z = up the slope (V/height)
    
    # Get direction vectors from origin along the two edges
    if u_edge.Vertexes[0].Point.distanceToPoint(origin) < 0.001:
        u_vec = u_edge.Vertexes[1].Point.sub(u_edge.Vertexes[0].Point).normalize()
    else:
        u_vec = u_edge.Vertexes[0].Point.sub(u_edge.Vertexes[1].Point).normalize()
    
    if v_edge.Vertexes[0].Point.distanceToPoint(origin) < 0.001:
        v_vec = v_edge.Vertexes[1].Point.sub(v_edge.Vertexes[0].Point).normalize()
    else:
        v_vec = v_edge.Vertexes[0].Point.sub(v_edge.Vertexes[1].Point).normalize()
    
    # Ensure V vector points UP the slope (positive Z component for sloped roofs)
    if v_vec.z < 0:
        v_vec = App.Vector(-v_vec.x, -v_vec.y, -v_vec.z)
    
    # Get normal from face
    normal = face.normalAt(0.5, 0.5).normalize()
    
    # Calculate face extents by projecting all vertices onto U and V directions
    # This handles complex faces (hexagons, heptagons) from Boolean cuts correctly
    u_projections = []
    v_projections = []
    
    for vertex in face.Vertexes:
        # Vector from origin to this vertex
        vec_to_vertex = vertex.Point.sub(origin)
        # Project onto U and V directions
        u_proj = vec_to_vertex.dot(u_vec)
        v_proj = vec_to_vertex.dot(v_vec)
        u_projections.append(u_proj)
        v_projections.append(v_proj)
    
    # Face extents are the range of projections
    u_length = max(u_projections) - min(u_projections)
    v_length = max(v_projections) - min(v_projections)
    
    return origin, u_vec, v_vec, normal, u_length, v_length


def scale_vector(vec, scale):
    """Properly scale a vector by component multiplication"""
    return App.Vector(vec.x * scale, vec.y * scale, vec.z * scale)


def compute_edge_intersection_angle(edge1, edge2):
    """
    Compute the dihedral angle between two roof edges/faces.
    
    Args:
        edge1: First edge (from a roof face)
        edge2: Second edge (from another roof face)
    
    Returns:
        Dictionary with:
            - angle_degrees: The dihedral angle in degrees
            - angle_radians: The dihedral angle in radians
            - bisector_direction: Unit vector along the angle bisector
            - edge1_normal: Normal of first face
            - edge2_normal: Normal of second face
    """
    # Get the faces adjacent to each edge
    # For now, we'll compute based on edge tangents and assume roof planes
    
    # Get edge tangent vectors
    tangent1 = edge1.Curve.Direction if hasattr(edge1.Curve, 'Direction') else edge1.tangentAt(edge1.FirstParameter)
    tangent2 = edge2.Curve.Direction if hasattr(edge2.Curve, 'Direction') else edge2.tangentAt(edge2.FirstParameter)
    
    # Normalize
    tangent1.normalize()
    tangent2.normalize()
    
    # Calculate angle between tangents
    dot_product = tangent1.dot(tangent2)
    # Clamp to [-1, 1] to handle floating point errors
    dot_product = max(-1.0, min(1.0, dot_product))
    
    angle_rad = math.acos(dot_product)
    angle_deg = math.degrees(angle_rad)
    
    # Calculate bisector direction (for valley/hip trim orientation)
    bisector = (tangent1 + tangent2).normalize()
    
    return {
        'angle_degrees': angle_deg,
        'angle_radians': angle_rad,
        'bisector_direction': bisector,
        'tangent1': tangent1,
        'tangent2': tangent2,
    }


def compute_face_intersection_angle(face1, face2):
    """
    Compute the dihedral angle between two roof faces at their intersection.
    This is the proper way to get valley/hip angles.
    
    Args:
        face1: First roof face
        face2: Second roof face
    
    Returns:
        Dictionary with:
            - dihedral_angle_degrees: The dihedral angle between faces
            - dihedral_angle_radians: The dihedral angle in radians
            - intersection_edge: The edge where faces meet (if they intersect)
            - normal1: Normal vector of face1
            - normal2: Normal vector of face2
            - is_valley: True if this is a valley (angle < 180°)
            - is_hip: True if this is a hip (angle > 180°)
    """
    # Get face normals
    uv1 = face1.ParameterRange
    u1_mid = (uv1[0] + uv1[1]) / 2
    v1_mid = (uv1[2] + uv1[3]) / 2
    normal1 = face1.normalAt(u1_mid, v1_mid)
    
    uv2 = face2.ParameterRange
    u2_mid = (uv2[0] + uv2[1]) / 2
    v2_mid = (uv2[2] + uv2[3]) / 2
    normal2 = face2.normalAt(u2_mid, v2_mid)
    
    # Calculate dihedral angle
    # The angle between normals gives us the dihedral angle
    dot_product = normal1.dot(normal2)
    dot_product = max(-1.0, min(1.0, dot_product))
    
    angle_rad = math.acos(dot_product)
    angle_deg = math.degrees(angle_rad)
    
    # Determine if valley or hip
    # This is actually quite difficult without additional context!
    # 
    # Rules of thumb:
    # 1. Small angles (<90°) between normals = faces point similar direction = likely HIP
    # 2. Large angles (>90°) between normals = faces point different directions = likely VALLEY
    # 3. But this can be wrong! User should verify visually.
    
    # Use angle between normals as primary heuristic
    if angle_deg < 90:
        # Normals point in similar direction = external ridge = HIP
        is_hip = True
        is_valley = False
        trim_angle = 180 - angle_deg
    else:
        # Normals point in different directions = internal corner = VALLEY
        is_valley = True
        is_hip = False
        trim_angle = 180 - angle_deg  # For valleys, also use supplementary angle
    
    # Note: This heuristic can be wrong! 
    # User should verify the result visually
    # Both valley and hip actually use 180 - angle for the trim piece angle
    
    # Try to find intersection edge
    intersection_edge = None
    try:
        # Get common edges between faces
        edges1 = set(face1.Edges)
        edges2 = set(face2.Edges)
        common_edges = edges1.intersection(edges2)
        if common_edges:
            intersection_edge = list(common_edges)[0]
    except:
        pass
    
    return {
        'dihedral_angle_degrees': angle_deg,
        'dihedral_angle_radians': angle_rad,
        'normal1': normal1,
        'normal2': normal2,
        'intersection_edge': intersection_edge,
        'is_valley': is_valley,
        'is_hip': is_hip,
        'trim_angle_degrees': trim_angle,
    }


def generate_shingles(face, base_object, params):
    """
    Generate shingles on a face.
    
    Args:
        face: The face to cover with shingles
        base_object: The actual base object (not its name!) - for PropertyLink reference
        params: Dictionary with parameters:
            - shingleWidth: Width of each shingle (mm)
            - shingleHeight: Height of each shingle (mm)
            - materialThickness: Thickness of material (mm)
            - shingleExposure: Exposed portion per course (mm)
            - shingleStaggerPattern: "half", "third", or "none"
            - shingleWedgeThickness: Base thickness of triangular wedges (mm)
    
    Returns:
        Part::Feature object containing the shingle compound
    """
    
    doc = App.ActiveDocument
    
    # Check if base_object is already a ShingledRoof compound
    # If so, extract the original base object to avoid recursive compounding
    original_base_obj = base_object
    
    if base_object.TypeId == 'Part::Compound':
        # Check if it's a ShingledRoof compound (has our metadata)
        if hasattr(base_object, 'BaseObject') and base_object.BaseObject:
            print(f"⚠️  Detected existing ShingledRoof compound: {base_object.Name}")
            print(f"   Using original base object: {base_object.BaseObject.Name}")
            original_base_obj = base_object.BaseObject
        elif 'ShingledRoof_' in base_object.Name:
            # It's a ShingledRoof but no BaseObject property - try to extract by name (fallback)
            original_base_name = base_object.Name.replace('ShingledRoof_', '', 1)
            print(f"⚠️  Detected ShingledRoof compound (no BaseObject property)")
            print(f"   Attempting to find: {original_base_name}")
            fallback_obj = doc.getObject(original_base_name)
            if fallback_obj:
                original_base_obj = fallback_obj
            else:
                print(f"   ⚠️  Could not find base object by name, using compound")
    
    base_obj = original_base_obj
    
    # Extract parameters
    shingle_width = params.get('shingleWidth', 10.0)
    shingle_height = params.get('shingleHeight', 20.0)
    shingle_thickness = params.get('materialThickness', 0.5)
    exposure = params.get('shingleExposure', 15.0)
    stagger_pattern = params.get('shingleStaggerPattern', 'half')
    wedge_thickness = params.get('shingleWedgeThickness', shingle_thickness)
    
    print(f"\n{'='*60}")
    print(f"Shingle Generator v{VERSION}")
    print(f"{'='*60}")
    print(f"Source: {base_obj.Name}")
    print(f"Shingle: {shingle_width} x {shingle_height} x {shingle_thickness} mm")
    print(f"Wedge base: {wedge_thickness} mm")
    print(f"Exposure: {exposure} mm")
    print(f"Stagger: {stagger_pattern}\n")
    
    # Get face coordinate system
    origin, u_vec, v_vec, normal, u_length, v_length = get_face_coordinate_system(face)
    
    # Check face normal direction - should point inward (downward for typical roofs)
    # If normal Z component is positive, flip the normal
    if normal.z > 0:
        normal = normal.multiply(-1)
        print(f"  ⚠ Flipped face normal to point inward\n")
    
    print(f"Face dimensions: {u_length:.1f} x {v_length:.1f} mm")
    
    # Use geometry library to calculate layout
    layout = calculate_layout(u_length, v_length, shingle_width, exposure, stagger_pattern)
    
    num_courses = layout['num_courses']
    shingles_per_course = layout['shingles_per_course']
    max_stagger = layout['max_stagger']
    
    print(f"Courses: {num_courses}")
    print(f"Shingles per course: {shingles_per_course}")
    print(f"Total (before trimming): {num_courses * shingles_per_course}\n")
    
    # Generate shingles with solid trapezoid geometry
    shingle_shapes = []
    
    # Create clipping volume based on face geometry
    # Extrude the face to create a 3D clipping volume that respects face orientation
    clip_margin = shingle_thickness * 2  # Allow small overhang for material thickness
    
    try:
        # Extrude face inward and outward to create clipping volume
        extrusion_depth = 100.0  # Large enough to capture all shingles
        clip_volume_pos = face.extrude(normal.multiply(extrusion_depth))
        clip_volume_neg = face.extrude(normal.multiply(-extrusion_depth))
        clip_volume = clip_volume_pos.fuse(clip_volume_neg)
        
        print(f"✓ Face-based clipping volume created\n")
    except Exception as e:
        print(f"Warning: Could not create face clipping volume: {e}")
        print(f"Proceeding without per-shingle clipping\n")
        clip_volume = None
    
    for row in range(num_courses):
        # Calculate stagger offset for this row (using geometry library)
        stagger = calculate_stagger_offset(row, stagger_pattern, shingle_width)
        
        for col in range(shingles_per_course):
            # Start before origin to ensure full coverage
            u = col * shingle_width + stagger - max_stagger
            v = row * exposure - exposure  # Start one course below origin
            
            # Calculate base position (top edge of shingle on roof surface)
            u_scaled = scale_vector(u_vec, u)
            v_scaled = scale_vector(v_vec, v)
            top_position = origin + u_scaled + v_scaled
            
            # Create shingle geometry based on row
            if row == 0:
                # Row 0: Rectangular box with exposed height only
                shingle_shape = Part.makeBox(shingle_width, exposure, shingle_thickness)
                
                # Align to face
                z_axis = App.Vector(0, 0, 1)
                rot1 = App.Rotation(z_axis, normal)
                x_after_rot1 = rot1.multVec(App.Vector(1, 0, 0))
                rot2 = App.Rotation(x_after_rot1, u_vec)
                final_rotation = rot2.multiply(rot1)
                
                shingle_shape.Placement = App.Placement(top_position, final_rotation)
                
            else:
                # Row 1+: Triangular wedge cross-section
                # Top edge: thin (wedge_thickness) against roof
                # Bottom edge: tapers to a point
                # Height: full shingle_height
                
                p1 = App.Vector(0, 0, 0)                      # Top back (against roof, uphill)
                p2 = App.Vector(0, 0, wedge_thickness)        # Top front (visible surface, uphill)  
                p3 = App.Vector(0, shingle_height, 0)         # Bottom point (tapers to roof surface)
                
                # Create edges connecting the points
                l1 = Part.LineSegment(p1, p2)
                l2 = Part.LineSegment(p2, p3)
                l3 = Part.LineSegment(p3, p1)
                
                # Make wire from edges
                profile_wire = Part.Wire([l1.toShape(), l2.toShape(), l3.toShape()])
                
                # Create face from wire
                profile_face = Part.Face(profile_wire)
                
                # Extrude along shingle width
                extrude_vector = App.Vector(shingle_width, 0, 0)
                shingle_shape = profile_face.extrude(extrude_vector)
                
                # Position and orient on the roof
                z_axis = App.Vector(0, 0, 1)
                rot1 = App.Rotation(z_axis, normal)
                x_after_rot1 = rot1.multVec(App.Vector(1, 0, 0))
                rot2 = App.Rotation(x_after_rot1, u_vec)
                final_rotation = rot2.multiply(rot1)
                
                shingle_shape.Placement = App.Placement(top_position, final_rotation)
            
            # Clip shingle to face boundary if clipping volume exists
            if clip_volume is not None:
                try:
                    clipped_shingle = shingle_shape.common(clip_volume)
                    # Only keep shingles with real geometry
                    if clipped_shingle.Volume > 0.001:
                        shingle_shapes.append(clipped_shingle)
                    # else: shingle was completely outside bounds, skip it
                except Exception as e:
                    # If clipping fails, keep original (graceful degradation)
                    if shingle_shape.Volume > 0.001:
                        shingle_shapes.append(shingle_shape)
            else:
                # No clipping volume, use original
                shingle_shapes.append(shingle_shape)
    
    print(f"Generated {len(shingle_shapes)} shingles\n")
    
    if len(shingle_shapes) == 0:
        raise ValueError("No shingles generated!")
    
    # Create a compound from all shingles (no Boolean operations)
    # This is fast and clean. If Boolean operations are needed later,
    # fuse the compound at that point (lazy evaluation).
    print("Creating compound from shingles...")
    compound_shape = Part.Compound(shingle_shapes)
    
    print(f"✓ Created compound with {len(shingle_shapes)} shingles\n")
    
    # Validate the compound
    if compound_shape.isNull():
        raise ValueError(f"Compound is invalid!")
    
    print(f"  Compound volume: {compound_shape.Volume:.1f} mm³")
    
    # Per-shingle clipping already removed overhang geometry
    # No additional trimming needed - shingles are already clipped to face bounds
    trimmed_compound = compound_shape
    print("✓ Shingles clipped to face boundaries during generation\n")
    
    # Create shingle skin as Part::Feature
    # Create shingle skin as Part::Feature
    shingle_skin_name = f"ShingleSkin_{base_obj.Name}"
    shingle_skin = doc.addObject("Part::Feature", shingle_skin_name)
    shingle_skin.Shape = trimmed_compound
    
    # Add metadata to shingle skin
    shingle_skin.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator name")
    shingle_skin.GeneratorName = GENERATOR_NAME
    
    shingle_skin.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
    shingle_skin.GeneratorVersion = VERSION
    
    print(f"✓ Created shingle skin: {shingle_skin_name}")
    
    # Create compound with the base object and shingle skin
    print(f"Creating compound of shingle skin + base object...")
    
    # Create a Part::Compound to hold both the base object and shingle skin
    result_name = f"ShingledRoof_{base_obj.Name}"
    result_obj = doc.addObject("Part::Compound", result_name)
    result_obj.Links = [base_obj, shingle_skin]
    
    # Add metadata to compound
    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator name")
    result_obj.GeneratorName = GENERATOR_NAME
    
    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
    result_obj.GeneratorVersion = VERSION
    
    result_obj.addProperty("App::PropertyLink", "BaseObject", "Metadata", "Base roof object")
    result_obj.BaseObject = base_obj
    
    result_obj.addProperty("App::PropertyLink", "ShingleSkin", "Metadata", "Shingle skin object")
    result_obj.ShingleSkin = shingle_skin
    
    print(f"✓ Created compound: {result_name}")
    print(f"  └─ Contains: {base_obj.Name} + {shingle_skin.Name}")
    
    doc.recompute()
    
    print(f"✓ Created: {result_name}")
    return result_obj


# ============================================================================
# Main execution
# ============================================================================

if __name__ == "__main__":
    
    doc = App.ActiveDocument
    
    if not doc:
        print("ERROR: No active document")
    else:
        print(f"\n{'='*60}")
        print(f"Shingle Generator v{VERSION}")
        print(f"{'='*60}\n")
        
        # Try to get parameters from spreadsheet
        params_sheet = doc.getObject("Spreadsheet")
        
        if params_sheet:
            try:
                params = get_params_from_spreadsheet(doc)
                if params:
                    print("Loaded parameters from spreadsheet:")
                    for key, val in params.items():
                        print(f"  {key}: {val}")
                    print()
                else:
                    print("Warning: Could not load parameters from spreadsheet, using defaults\n")
                    params = {
                        'shingleWidth': 3.5,
                        'shingleHeight': 2.0,
                        'materialThickness': 0.25,
                        'shingleExposure': 1.5,
                        'shingleStaggerPattern': 'half'
                    }
            except Exception as e:
                print(f"Warning: {e}")
                print("Using default parameters\n")
                params = {
                    'shingleWidth': 3.5,
                    'shingleHeight': 2.0,
                    'materialThickness': 0.25,
                    'shingleExposure': 1.5,
                    'shingleStaggerPattern': 'half'
                }
        else:
            print("No spreadsheet found, using default parameters:")
            params = {
                'shingleWidth': 3.5,
                'shingleHeight': 2.0,
                'materialThickness': 0.25,
                'shingleExposure': 1.5,
                'shingleStaggerPattern': 'half'
            }
            for key, val in params.items():
                print(f"  {key}: {val}")
            print()
        
        # Validate parameters early
        is_valid, errors = validate_parameters(
            params['shingleWidth'],
            params['shingleHeight'],
            params['materialThickness'],
            params['shingleExposure']
        )
        
        if not is_valid:
            print("ERROR: Invalid parameters:")
            for error in errors:
                print(f"  - {error}")
            print()
        else:
            is_valid, msg = validate_stagger_pattern(params['shingleStaggerPattern'])
            if not is_valid:
                print(f"ERROR: {msg}\n")
            else:
                # Get selected faces
                selection = Gui.Selection.getSelectionEx()
                
                if not selection:
                    print("ERROR: No faces selected!")
                    print("\nUsage:")
                    print("1. Select one or more roof faces (Ctrl+click in 3D view)")
                    print("2. Run this macro")
                    print()
                elif not selection[0].HasSubObjects:
                    print("ERROR: Please select faces, not just objects")
                    print("\nUsage:")
                    print("1. Select one or more faces by Ctrl+clicking on roof surfaces")
                    print("2. Run this macro")
                    print()
                else:
                    # Process selected faces
                    success_count = 0
                    fail_count = 0
                    
                    for sel in selection:
                        obj_name = sel.Object.Label
                        base_obj = sel.Object  # Pass the actual object, not its name!
                        
                        for sub_element in sel.SubElementNames:
                            if not sub_element.startswith("Face"):
                                print(f"ERROR: '{sub_element}' is not a face, skipping\n")
                                continue
                            
                            try:
                                # Get the actual face object
                                face_index = int(sub_element[4:]) - 1  # Face6 -> index 5
                                face = sel.Object.Shape.Faces[face_index]
                                
                                print(f"\n{'='*60}")
                                print(f"Processing: {obj_name} / {sub_element}")
                                print(f"{'='*60}")
                                
                                # Generate shingles for this face - pass actual object, not name!
                                result = generate_shingles(face, base_obj, params)
                                
                                print(f"\n✓ SUCCESS: Generated shingles for {obj_name}/{sub_element}\n")
                                success_count += 1
                                
                            except Exception as e:
                                print(f"\n✗ FAILED: {e}\n")
                                fail_count += 1
                                import traceback
                                traceback.print_exc()
                    
                    print(f"\n{'='*60}")
                    print(f"SUMMARY: {success_count} succeeded, {fail_count} failed")
                    print(f"{'='*60}\n")
