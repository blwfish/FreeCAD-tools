"""
Parametric Clapboard Siding Generator for FreeCAD v6.0.0
Generates realistic clapboard siding from explicitly selected FACES

Author: Generated for model railroading (HO/O/N scale)
Usage: Click on specific faces in the 3D view, then run this macro

Version History:
- 6.0.0: ADD: Global grid snapping for course alignment across all faces
         ADD: Single compound output from multiple selected faces
         FIX: Clapboard courses now align perfectly across coplanar faces
         CHANGE: Multi-face workflow creates one result object instead of multiple
         IMPROVEMENT: Eliminates visible seams at face boundaries
- 5.4.0: ADD: Bay boundary detection for fused arrays with vertical gaps
         FIX: Clapboards now respect bay separations (fudgeFactor-sized gaps)
         CHANGE: Segmented clapboard generation stops at detected boundaries
- 5.3.0: CHANGE: SourceObject now uses App::PropertyLink (TNP-safe object reference)
         CHANGE: Stores actual object reference instead of label string
- 5.2.0: CHANGE: Return skin-only geometry, use Part::Compound output
         FIX: Eliminate duplicate wall geometry in output
- 5.1.0: REMOVE: Trim logic (defer to smart_trim generator)
         CHANGE: Fuse clapboards directly to source wall (boolean now, validate early)
         REMOVE: trim_width and trim_thickness parameters
- 5.0.1: ADD: Sketch geometry validation - detect degenerate and duplicate edges
- 5.0.0: REWRITE - Face-based selection (not sketches)
"""

import FreeCAD as App
import Part
from FreeCAD import Vector
import math

VERSION = "6.0.0"
GENERATOR_NAME = "clapboard_generator"
CLAPBOARD_TRIM_OFFSET = 0.05  # mm - Keep clapboard bottom slightly inboard of trim to avoid coplanar faces


def find_spreadsheet(doc, preferred_names):
    """Find spreadsheet by checking both object name and label."""
    for ss_name in preferred_names:
        obj = doc.getObject(ss_name)
        if obj and obj.TypeId == 'Spreadsheet::Sheet':
            print(f"Found spreadsheet by name: '{ss_name}'")
            return obj
        
        for obj in doc.Objects:
            if obj.TypeId == 'Spreadsheet::Sheet' and obj.Label == ss_name:
                print(f"Found spreadsheet by label: '{ss_name}' (object name: '{obj.Name}')")
                return obj
    
    return None


def get_params_from_spreadsheet(doc):
    """Try to read clapboard parameters from spreadsheet."""
    preferred_names = ["params", "ClapboardParameters", "BuildingParameters", "Spreadsheet"]
    
    ss = find_spreadsheet(doc, preferred_names)
    if ss is None:
        return None
    
    params = {}
    param_map = {
        'clapboard_height': ['clapboard_height', 'ClapboardHeight', 'clapboardHeight', 'reveal'],
        'clapboard_thickness': ['clapboard_thickness', 'ClapboardThickness', 'thickness', 'materialThickness'],
    }
    
    for param_key, possible_names in param_map.items():
        for name in possible_names:
            try:
                val = ss.get(name)
                if val is not None:
                    params[param_key] = float(val)
                    break
            except:
                continue
    
    return params if params else None


def check_for_degenerate_edges(wire):
    """Detect edges with zero or near-zero length."""
    degenerate = []
    tolerance = 0.001  # mm
    
    for i, edge in enumerate(wire.Edges):
        if edge.Length < tolerance:
            degenerate.append((i, edge.Length))
    
    return degenerate


def check_for_duplicate_edges(wire):
    """Detect duplicate or overlapping edges in a wire."""
    edges = wire.Edges
    duplicates = []
    tolerance = 0.001  # mm
    
    for i in range(len(edges)):
        for j in range(i + 1, len(edges)):
            edge1 = edges[i]
            edge2 = edges[j]
            
            e1_start = edge1.valueAt(edge1.FirstParameter)
            e1_end = edge1.valueAt(edge1.LastParameter)
            e2_start = edge2.valueAt(edge2.FirstParameter)
            e2_end = edge2.valueAt(edge2.LastParameter)
            
            if (e1_start.distanceToPoint(e2_start) < tolerance and
                e1_end.distanceToPoint(e2_end) < tolerance):
                duplicates.append((i, j))
            elif (e1_start.distanceToPoint(e2_end) < tolerance and
                  e1_end.distanceToPoint(e2_start) < tolerance):
                duplicates.append((i, j))
    
    return duplicates


def validate_wire_geometry(wire, wire_name="Wire"):
    """Validate wire for common geometry errors."""
    degenerate = check_for_degenerate_edges(wire)
    if degenerate:
        errors = [f"  Edge {i}: length={length:.6f}mm" for i, length in degenerate]
        raise ValueError(
            f"{wire_name} has {len(degenerate)} degenerate edge(s):\n" +
            "\n".join(errors) +
            "\nThese are likely duplicate/overlapping lines in your sketch.\n" +
            "Check for stray geometry in the Sketcher!"
        )
    
    duplicates = check_for_duplicate_edges(wire)
    if duplicates:
        errors = [f"  Edges {i} and {j}" for i, j in duplicates]
        raise ValueError(
            f"{wire_name} has {len(duplicates)} duplicate edge(s):\n" +
            "\n".join(errors) +
            "\nThese are overlapping lines in your sketch.\n" +
            "Check for stray geometry in the Sketcher!"
        )


def get_selected_faces():
    """Get explicitly selected faces from FreeCAD selection."""
    import FreeCADGui
    
    faces_list = []
    selection_ex = FreeCADGui.Selection.getSelectionEx()
    
    if len(selection_ex) == 0:
        raise ValueError("No objects selected!")
    
    for sel_obj in selection_ex:
        obj = sel_obj.Object
        
        if not hasattr(obj, 'Shape'):
            print(f"Warning: '{obj.Label}' has no Shape property")
            continue
        
        if len(sel_obj.SubElementNames) > 0:
            for sub_name in sel_obj.SubElementNames:
                if sub_name.startswith('Face'):
                    try:
                        face_num = int(sub_name[4:]) - 1
                        
                        if face_num < len(obj.Shape.Faces):
                            face = obj.Shape.Faces[face_num]
                            faces_list.append((obj, face, face_num))
                            print(f"  Selected: {sub_name} from '{obj.Label}'")
                        else:
                            print(f"Warning: Face index {face_num} out of range for '{obj.Label}'")
                    except ValueError:
                        print(f"Warning: Could not parse face number from '{sub_name}'")
        else:
            raise ValueError(
                f"Please select specific FACES, not the whole object!\n"
                f"Click in the 3D view to select '{obj.Label}',\n"
                f"then Ctrl+click on the specific faces you want clapboards on."
            )
    
    if len(faces_list) == 0:
        raise ValueError("No faces explicitly selected! Please Ctrl+click on the faces you want.")
    
    return faces_list


def get_face_wires(face):
    """Get wires from a face (outer boundary and holes)."""
    wires = face.Wires
    
    if len(wires) == 0:
        raise ValueError("Face has no wires!")
    
    outer_wire = max(wires, key=lambda w: abs(Part.Face(w).Area))
    hole_wires = [w for w in wires if w != outer_wire]
    
    if not outer_wire.isClosed():
        raise ValueError("Outer wire is not closed! Cannot generate clapboards.")
    
    for i, hw in enumerate(hole_wires):
        if not hw.isClosed():
            raise ValueError(f"Hole wire {i} is not closed!")
    
    validate_wire_geometry(outer_wire, "Outer wire")
    
    for i, hw in enumerate(hole_wires):
        validate_wire_geometry(hw, f"Hole wire {i}")
    
    return outer_wire, hole_wires


def get_face_bounding_box_local(face):
    """Get bounding box of a face in its local coordinates."""
    return face.BoundBox


def get_face_normal(face):
    """Get the normal vector of a face at its center."""
    u_range = face.ParameterRange[:2]
    v_range = face.ParameterRange[2:]
    u_mid = (u_range[0] + u_range[1]) / 2
    v_mid = (v_range[0] + v_range[1]) / 2
    normal = face.normalAt(u_mid, v_mid)
    return normal


def snap_to_global_grid(bbox, clapboard_height, vertical_axis='z'):
    """
    Snap vertical starting position to global grid for course alignment.
    
    This ensures clapboard courses align across all coplanar faces,
    eliminating visible seams at face boundaries.
    
    Args:
        bbox: Face bounding box
        clapboard_height: Height of each clapboard course (mm)
        vertical_axis: Which axis is vertical ('z' or 'y')
        
    Returns:
        Adjusted vertical minimum position (snapped to grid)
    """
    # Get the vertical minimum from bounding box
    if vertical_axis == 'z':
        vert_min = bbox.ZMin
    else:
        vert_min = bbox.YMin
    
    # Snap to global grid based on clapboard_height intervals
    grid_spacing = clapboard_height
    snapped_vert_min = round(vert_min / grid_spacing) * grid_spacing
    
    # Calculate adjustment
    adjustment = snapped_vert_min - vert_min
    
    if abs(adjustment) > 0.001:  # Only report if meaningful
        print(f"  Grid snapping: adjusted vertical start by {adjustment:.3f}mm")
        print(f"    {vertical_axis.upper()}: {vert_min:.3f} → {snapped_vert_min:.3f} mm")
    
    return snapped_vert_min


def detect_face_orientation(bbox):
    """Detect which plane a face lies in based on bounding box extents."""
    x_extent = bbox.XMax - bbox.XMin
    y_extent = bbox.YMax - bbox.YMin
    z_extent = bbox.ZMax - bbox.ZMin
    
    tolerance = 0.1
    
    if x_extent < tolerance:
        return 'z', 'y', 'x'
    elif y_extent < tolerance:
        return 'z', 'x', 'y'
    elif z_extent < tolerance:
        return 'y', 'x', 'z'
    else:
        if z_extent >= y_extent and z_extent >= x_extent:
            if x_extent > y_extent:
                return 'z', 'x', 'y'
            else:
                return 'z', 'y', 'x'
        else:
            return 'y', 'x', 'z'


def find_gable_edges(wire, vertical_axis='y', angle_tolerance=5.0):
    """Find non-vertical edges in the wire that define gable profiles."""
    gable_edges = []
    
    if vertical_axis == 'z':
        vert_dir = Vector(0, 0, 1)
    else:
        vert_dir = Vector(0, 1, 0)
    
    for edge in wire.Edges:
        if edge.Length < 0.01:
            continue
        
        try:
            direction = edge.tangentAt(edge.FirstParameter)
            direction.normalize()
            
            dot_product = abs(direction.dot(vert_dir))
            angle = math.degrees(math.acos(min(1.0, dot_product)))
            
            if angle > angle_tolerance:
                gable_edges.append(edge)
                print(f"  Found gable edge: angle={angle:.1f}° from vertical")
        
        except Exception as e:
            print(f"Warning: Could not analyze edge: {e}")
    
    return gable_edges


def find_bay_boundaries(outer_wire, horizontal_axis='x', vertical_axis='z', gap_threshold=0.0005):
    """
    Find vertical gaps in the outer wire that represent bay boundaries.
    
    Returns list of horizontal positions where bays are separated.
    These are detected as discontinuities (gaps) in the vertical coverage.
    """
    # Get all vertical edges and their horizontal positions
    if vertical_axis == 'z':
        vert_dir = Vector(0, 0, 1)
    else:
        vert_dir = Vector(0, 1, 0)
    
    angle_tolerance = 5.0  # degrees from vertical
    vertical_edges = []
    
    for edge in outer_wire.Edges:
        if edge.Length < 0.01:
            continue
        
        try:
            direction = edge.tangentAt(edge.FirstParameter)
            direction.normalize()
            
            dot_product = abs(direction.dot(vert_dir))
            angle = math.degrees(math.acos(min(1.0, dot_product)))
            
            # This is a vertical edge
            if angle < angle_tolerance:
                start = edge.valueAt(edge.FirstParameter)
                end = edge.valueAt(edge.LastParameter)
                
                # Get horizontal position
                if horizontal_axis == 'x':
                    h_pos = (start.x + end.x) / 2
                else:
                    h_pos = (start.y + end.y) / 2
                
                vertical_edges.append({
                    'h_pos': h_pos,
                    'edge': edge,
                    'start': start,
                    'end': end
                })
        except Exception as e:
            continue
    
    if len(vertical_edges) < 2:
        return []
    
    # Sort by horizontal position
    vertical_edges.sort(key=lambda e: e['h_pos'])
    
    # Find gaps between adjacent vertical edges
    bay_boundaries = []
    
    for i in range(len(vertical_edges) - 1):
        h1 = vertical_edges[i]['h_pos']
        h2 = vertical_edges[i + 1]['h_pos']
        gap = h2 - h1
        
        # If gap is larger than threshold, this is a bay boundary
        if gap > gap_threshold:
            # Store the midpoint of the gap as the boundary
            boundary_pos = (h1 + h2) / 2
            bay_boundaries.append(boundary_pos)
            print(f"  Found bay boundary at {horizontal_axis}={boundary_pos:.3f} (gap={gap:.4f}mm)")
    
    return bay_boundaries


def create_clapboard_course_local(vert_position, bbox, clapboard_height, clapboard_thickness,
                                  vertical_axis, horizontal_axis, normal, bay_boundaries=None):
    """Create one horizontal clapboard course, split at bay boundaries if provided."""
    actual_thick = clapboard_thickness - CLAPBOARD_TRIM_OFFSET
    thin_thickness = 0.01
    
    # If no bay boundaries, create one continuous clapboard
    if not bay_boundaries or len(bay_boundaries) == 0:
        bay_boundaries = []
    
    # Get overall horizontal range
    if horizontal_axis == 'x':
        h_min_overall = bbox.XMin - 0.1
        h_max_overall = bbox.XMax + 0.1
    else:
        h_min_overall = bbox.YMin - 0.1
        h_max_overall = bbox.YMax + 0.1
    
    # Create segments between boundaries
    segments = []
    prev_boundary = h_min_overall
    
    for boundary in sorted(bay_boundaries):
        if boundary > prev_boundary + 0.001:  # Skip tiny segments
            segments.append((prev_boundary, boundary))
        prev_boundary = boundary
    
    # Add final segment
    if prev_boundary < h_max_overall - 0.001:
        segments.append((prev_boundary, h_max_overall))
    
    # If no boundaries were valid, use full width
    if len(segments) == 0:
        segments = [(h_min_overall, h_max_overall)]
    
    # Create clapboard pieces for each segment
    pieces = []
    
    for h_min, h_max in segments:
        clapboard_shape = None
        
        if vertical_axis == 'z':
            if horizontal_axis == 'x':
                v_bottom, v_top = vert_position, vert_position + clapboard_height
                v_max = bbox.ZMax + 0.1
                
                if v_top > v_max:
                    v_top = v_max
                if v_bottom >= bbox.ZMax:
                    continue
                
                base_y = bbox.YMin
                thick_offset = actual_thick if normal.y > 0 else -actual_thick
                thin_offset = thin_thickness if normal.y > 0 else -thin_thickness
                
                outside_wire = Part.makePolygon([
                    Vector(h_min, base_y + thick_offset, v_bottom),
                    Vector(h_max, base_y + thick_offset, v_bottom),
                    Vector(h_max, base_y + thin_offset, v_top),
                    Vector(h_min, base_y + thin_offset, v_top),
                    Vector(h_min, base_y + thick_offset, v_bottom)
                ])
                inside_wire = Part.makePolygon([
                    Vector(h_min, base_y, v_bottom),
                    Vector(h_max, base_y, v_bottom),
                    Vector(h_max, base_y, v_top),
                    Vector(h_min, base_y, v_top),
                    Vector(h_min, base_y, v_bottom)
                ])
                clapboard_shape = Part.makeLoft([inside_wire, outside_wire], True)
                
            else:  # horizontal_axis == 'y'
                v_bottom, v_top = vert_position, vert_position + clapboard_height
                v_max = bbox.ZMax + 0.1
                
                if v_top > v_max:
                    v_top = v_max
                if v_bottom >= bbox.ZMax:
                    continue
                
                base_x = bbox.XMin
                thick_offset = actual_thick if normal.x > 0 else -actual_thick
                thin_offset = thin_thickness if normal.x > 0 else -thin_thickness
                
                outside_wire = Part.makePolygon([
                    Vector(base_x + thick_offset, h_min, v_bottom),
                    Vector(base_x + thick_offset, h_max, v_bottom),
                    Vector(base_x + thin_offset, h_max, v_top),
                    Vector(base_x + thin_offset, h_min, v_top),
                    Vector(base_x + thick_offset, h_min, v_bottom)
                ])
                inside_wire = Part.makePolygon([
                    Vector(base_x, h_min, v_bottom),
                    Vector(base_x, h_max, v_bottom),
                    Vector(base_x, h_max, v_top),
                    Vector(base_x, h_min, v_top),
                    Vector(base_x, h_min, v_bottom)
                ])
                clapboard_shape = Part.makeLoft([inside_wire, outside_wire], True)
        else:  # vertical_axis == 'y'
            v_bottom, v_top = vert_position, vert_position + clapboard_height
            v_max = bbox.YMax + 0.1
            
            if v_top > v_max:
                v_top = v_max
            if v_bottom >= bbox.YMax:
                continue
            
            base_z = 0
            thick_offset = actual_thick if normal.z > 0 else -actual_thick
            thin_offset = thin_thickness if normal.z > 0 else -thin_thickness
            
            outside_wire = Part.makePolygon([
                Vector(h_min, v_bottom, base_z + thick_offset),
                Vector(h_max, v_bottom, base_z + thick_offset),
                Vector(h_max, v_top, base_z + thin_offset),
                Vector(h_min, v_top, base_z + thin_offset),
                Vector(h_min, v_bottom, base_z + thick_offset)
            ])
            inside_wire = Part.makePolygon([
                Vector(h_min, v_bottom, base_z),
                Vector(h_max, v_bottom, base_z),
                Vector(h_max, v_top, base_z),
                Vector(h_min, v_top, base_z),
                Vector(h_min, v_bottom, base_z)
            ])
            clapboard_shape = Part.makeLoft([inside_wire, outside_wire], True)
        
        if clapboard_shape:
            pieces.append(clapboard_shape)
    
    # If we created multiple pieces, fuse them
    if len(pieces) == 0:
        return None
    elif len(pieces) == 1:
        return pieces[0]
    else:
        return pieces[0].fuse(pieces[1:])


def create_clapboard_wall(face, source_object, clapboard_height=0.8, clapboard_thickness=0.2):
    """Generate clapboard siding from a face and fuse to source wall."""
    print(f"\nGenerating clapboards for face from '{source_object.Label}' (v{VERSION})...")
    
    outer_wire, hole_wires = get_face_wires(face)
    
    bbox = get_face_bounding_box_local(face)
    print(f"Face bounds: X=[{bbox.XMin:.1f}, {bbox.XMax:.1f}], "
          f"Y=[{bbox.YMin:.1f}, {bbox.YMax:.1f}], Z=[{bbox.ZMin:.1f}, {bbox.ZMax:.1f}]")
    
    vertical_axis, horizontal_axis, plane_normal = detect_face_orientation(bbox)
    print(f"Orientation: vertical={vertical_axis}, horizontal={horizontal_axis}")
    
    normal = get_face_normal(face)
    print(f"Face normal (local): ({normal.x:.3f}, {normal.y:.3f}, {normal.z:.3f})")
    
    parts = []
    
    # Detect bay boundaries from vertical gaps in the face
    print("Checking for bay boundaries...")
    gap_threshold = 0.0005  # Half of fudgeFactor (0.001mm)
    bay_boundaries = find_bay_boundaries(outer_wire, horizontal_axis, vertical_axis, gap_threshold)
    
    if len(bay_boundaries) > 0:
        print(f"Found {len(bay_boundaries)} bay boundaries - will create segmented clapboards")
    else:
        print("No bay boundaries detected - creating continuous clapboards")
    
    # Create clapboard courses
    print("Creating clapboard courses...")
    if vertical_axis == 'z':
        wall_height = bbox.ZMax - bbox.ZMin
        vert_min = bbox.ZMin
    else:
        wall_height = bbox.YMax - bbox.YMin
        vert_min = bbox.YMin
    
    # Snap starting position to global grid for course alignment
    vert_min = snap_to_global_grid(bbox, clapboard_height, vertical_axis)
    
    num_courses = int(math.ceil(wall_height / clapboard_height))
    print(f"Height: {wall_height:.2f}mm = {num_courses} courses")
    
    successful = 0
    for i in range(num_courses):
        overlap = 0.01 if i > 0 else 0
        vert_pos = vert_min + i * clapboard_height - overlap
        
        try:
            clapboard = create_clapboard_course_local(
                vert_pos, bbox, clapboard_height, clapboard_thickness,
                vertical_axis, horizontal_axis, normal, bay_boundaries
            )
            if clapboard:
                parts.append(clapboard)
                successful += 1
        except Exception as e:
            print(f"Warning: Course {i} failed: {e}")
    
    print(f"Created {successful}/{num_courses} courses")
    
    if len(parts) == 0:
        raise RuntimeError("No clapboard courses created!")
    
    # Fuse all clapboard courses
    print("Fusing clapboard courses...")
    if len(parts) == 1:
        fused_clapboards = parts[0]
    else:
        fused_clapboards = parts[0].fuse(parts[1:])
    
    print(f"Fused clapboards volume: {fused_clapboards.Volume:.2f} mm³")
    
    # Check for gable edges
    print("Checking for gable edges...")
    gable_edges = find_gable_edges(outer_wire, vertical_axis)
    
    if len(gable_edges) > 0:
        print(f"Found {len(gable_edges)} gable edges - cutting profile...")
        try:
            gable_solid_out = face.extrude(normal * clapboard_thickness * 3)
            gable_solid_in = face.extrude(normal * -(clapboard_thickness * 2))
            gable_solid = gable_solid_out.fuse(gable_solid_in)
            fused_clapboards = fused_clapboards.common(gable_solid)
        except Exception as e:
            print(f"Warning: Gable cutting failed: {e}")
    
    # Cut holes
    print(f"Cutting {len(hole_wires)} holes...")
    final_clapboards = fused_clapboards
    
    holes_cut = 0
    for i, hole_wire in enumerate(hole_wires):
        try:
            hole_face = Part.Face(hole_wire)
            hole_volume_fwd = hole_face.extrude(normal * clapboard_thickness * 2)
            hole_volume_back = hole_face.extrude(normal * -(clapboard_thickness * 3))
            hole_volume = hole_volume_fwd.fuse(hole_volume_back)
            
            volume_before = final_clapboards.Volume
            final_clapboards = final_clapboards.cut(hole_volume)
            volume_after = final_clapboards.Volume
            
            if volume_before - volume_after > 0.001:
                holes_cut += 1
                print(f"  Hole {i}: OK")
        except Exception as e:
            print(f"  Warning: Hole {i} failed: {e}")
    
    print(f"Cut {holes_cut}/{len(hole_wires)} holes")
    
    # Return only the clapboard skin geometry (don't fuse with source wall)
    print(f"\nClapboard siding complete (compounding with source wall in document)")
    print(f"Clapboard volume: {final_clapboards.Volume:.2f} mm³")
    return final_clapboards


# Main execution
if __name__ == '__main__' or __name__ == '__console__' or __name__ == '__plugins__':
    doc = App.activeDocument()
    if doc is None:
        App.Console.PrintError("No active document!\n")
    else:
        try:
            faces_list = get_selected_faces()
        except ValueError as e:
            App.Console.PrintError(f"Error: {e}\n")
            faces_list = []
        
        if len(faces_list) == 0:
            App.Console.PrintError("No faces selected!\n")
        else:
            params = get_params_from_spreadsheet(doc)
            
            if params:
                App.Console.PrintMessage("Using parameters from spreadsheet\n")
                clapboard_height = params.get('clapboard_height', 0.8)
                clapboard_thickness = params.get('clapboard_thickness', 0.2)
            else:
                App.Console.PrintMessage("Using HO scale defaults\n")
                clapboard_height = 0.8
                clapboard_thickness = 0.2
            
            if len(faces_list) > 1:
                App.Console.PrintMessage(f"\n=== Processing {len(faces_list)} faces ===\n")
            
            # Collect all clapboard skins from all faces
            all_clapboard_skins = []
            faces_processed = []
            source_objects = set()
            
            # Process each selected face
            for face_num, (source_obj, face, face_idx) in enumerate(faces_list, 1):
                try:
                    App.Console.PrintMessage(f"\n--- Processing face {face_num}/{len(faces_list)}: Face{face_idx + 1} from '{source_obj.Label}' ---\n")
                    
                    clapboard_skin = create_clapboard_wall(
                        face, source_obj, clapboard_height, clapboard_thickness
                    )
                    
                    # Add this face's clapboards to the collection
                    all_clapboard_skins.append(clapboard_skin)
                    faces_processed.append(f"Face{face_idx + 1}")
                    source_objects.add(source_obj)
                    
                    App.Console.PrintMessage(f"  ✓ Face{face_idx + 1} complete\n")
                    
                except Exception as e:
                    App.Console.PrintError(f"  ✗ Face{face_idx + 1} from '{source_obj.Label}': {e}\n")
                    import traceback
                    traceback.print_exc()
                    continue
            
            # Create final compound of all faces
            if all_clapboard_skins:
                App.Console.PrintMessage(f"\n{'='*60}\n")
                App.Console.PrintMessage(f"Creating final compound from {len(faces_processed)} face(s)...\n")
                App.Console.PrintMessage(f"{'='*60}\n")
                
                try:
                    # Create single compound shape
                    if len(all_clapboard_skins) == 1:
                        final_shape = all_clapboard_skins[0]
                    else:
                        final_shape = Part.Compound(all_clapboard_skins)
                    
                    # Determine output name
                    if len(source_objects) == 1:
                        obj_name = list(source_objects)[0].Label
                    else:
                        obj_name = "MultipleObjects"
                    
                    # Create result object
                    result_obj = doc.addObject("Part::Feature", f"ClapboardWall_{obj_name}")
                    result_obj.Shape = final_shape
                    
                    # Add metadata
                    result_obj.addProperty("App::PropertyString", "GeneratorName", "Metadata", "Generator that created this")
                    result_obj.addProperty("App::PropertyString", "GeneratorVersion", "Metadata", "Generator version")
                    result_obj.addProperty("App::PropertyString", "SourceFaces", "Metadata", "Source faces")
                    result_obj.addProperty("App::PropertyFloat", "ClapboardHeight", "Metadata", "Clapboard reveal height")
                    result_obj.addProperty("App::PropertyFloat", "ClapboardThickness", "Metadata", "Clapboard material thickness")
                    
                    result_obj.GeneratorName = GENERATOR_NAME
                    result_obj.GeneratorVersion = VERSION
                    result_obj.SourceFaces = ", ".join(faces_processed)
                    result_obj.ClapboardHeight = clapboard_height
                    result_obj.ClapboardThickness = clapboard_thickness
                    
                    doc.recompute()
                    
                    App.Console.PrintMessage(f"\n✓ Created: {result_obj.Label}\n")
                    App.Console.PrintMessage(f"  Faces processed: {len(faces_processed)}\n")
                    App.Console.PrintMessage(f"  Clapboard height: {clapboard_height}mm\n")
                    App.Console.PrintMessage(f"  Clapboard thickness: {clapboard_thickness}mm\n")
                    App.Console.PrintMessage(f"\n{'='*60}\n")
                    App.Console.PrintMessage(f"SUCCESS!\n")
                    App.Console.PrintMessage(f"{'='*60}\n")
                    
                except Exception as e:
                    App.Console.PrintError(f"\n{'='*60}\n")
                    App.Console.PrintError(f"ERROR creating final compound: {e}\n")
                    App.Console.PrintError(f"{'='*60}\n")
                    import traceback
                    traceback.print_exc()
            else:
                App.Console.PrintError("\nERROR: No faces were successfully processed\n")

